# 异常介绍
## 异常的概念
1. **异常的概述：异常（Exception）** 是指程序在运行过程中发生的 **不正常情况**，它会导致程序的正常执行流程被中断。比如：
+ 访问数组越界
+ 除数为 0
+ 文件未找到
+ 空指针访问（NullPointerException）
2. **异常体系结构**

 Java 中的所有异常都继承自 `java.lang.Throwable`，  主要分为`Error`和`Exception`两大类：

| 类型 | 继承自 | 是否必须处理 | 示例 |
| --- | --- | --- | --- |
| **Error（错误）** | `Throwable` | 否（程序无法恢复） | `OutOfMemoryError`<br/>、`StackOverflowError` |
| **Exception（异常）** | `Throwable` | 是（程序可恢复） | `IOException`<br/>、`SQLException` |


其中`Exception`又分为两大类：

| 分类 | 含义 | 是否必须处理 | 示例 |
| --- | --- | --- | --- |
| **编译时异常/受检异常（Checked Exception）** | 在编译期必须处理，否则编译不通过 | 必须处理 | `IOException`<br/>, `SQLException` |
| **运行时异常/非受检异常（Unchecked Exception）** | 运行时才可能发生，编译器不要求强制处理 | 可选处理 | `NullPointerException`<br/>, `ArrayIndexOutOfBoundsException`<br/>, `ArithmeticException` |


3. 异常体系图

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762999936606-176f73f6-0fc5-43cc-aa7f-741719567ff0.png)

## 常见的异常
### 常见的运行时异常
1. `<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">NullPointerException</font>`<font style="color:rgb(31, 35, 40);"> </font><font style="color:rgb(31, 35, 40);">空指针异常</font>
2. `<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">ArithmeticException</font>`<font style="color:rgb(31, 35, 40);"> 数学运算异常，例如一个整数除以零时会抛出此类异常</font>
3. `<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">ArrayIndexOutOfBoundsException</font>`<font style="color:rgb(31, 35, 40);"> 数组下标越界异常，例如索引为负或大于等于数组大小</font>
4. `<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">ClassCastException</font>`<font style="color:rgb(31, 35, 40);"> </font><font style="color:rgb(31, 35, 40);">类型转换异常</font>
5. `<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">NumberFormatException</font>`<font style="color:rgb(31, 35, 40);"> 数字格式不正确异常，例如当应用程序试图将字符串转换成一种数值类型，但是该字符串不能转换为适当格式时，抛出该异常</font>

### 常见的编译时异常
`<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">SQLException</font>`<font style="color:rgb(31, 35, 40);">：操作数据库时，查询表可能发生异常</font>

`<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">IOException</font>`<font style="color:rgb(31, 35, 40);">：操作文件时，发生的异常</font>

`<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">FileNotFoundException</font>`<font style="color:rgb(31, 35, 40);">：当操作一个不存在的文件时，发生异</font>

`<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">ClassNotFoundException</font>`<font style="color:rgb(31, 35, 40);">：加载类,而该类不存在时，异常</font>

`<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">EOFException</font>`<font style="color:rgb(31, 35, 40);">：操作文件,到文件末尾,发生异常</font>

`<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">IlegalArguementException</font>`<font style="color:rgb(31, 35, 40);"> ：参数异常</font>

# 异常处理I方式
## 使用`try...catch`捕获异常
### 捕获一个异常
1. 格式

```java
try{
    //可能发生异常的代码
} catch {
    //处理异常的代码
}
```

2. 示例

```java
package com.aurora.ExceptionDemo;

public class try_catch_Demo {
    public static void main(String[] args) {
        try {
            int result = 10 / 0;
            System.out.println("result is " + result);
        } catch (ArithmeticException e) {
            System.out.println("除数不能为0");
        }

        System.out.println("程序继续运行");
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762666008124-58bc21a0-7856-4bd5-b4d8-52b5f4cd2809.png)

### 多个catch捕获不同异常
1. 捕获多个异常的示例

 如果 `try` 语句块中有多种可能异常，可以使用 **多个 catch** 来分别处理。  

```java
package com.aurora.ExceptionDemo;

public class try_catch_Demo02 {
    public static void main(String[] args) {
        //使用try catch捕获多个异常
        try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[5]);     //数组越界，跳转到第一个catch
            int result = 10 / 0;            //不会执行到这里
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("数组越界");
        } catch (ArithmeticException e) {
            System.out.println("除数不能为0");
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762666394963-9ab8047f-1d24-4892-8625-63c41a7813fd.png)

2. **注意：**
+ **只会执行第一个匹配的 **`**catch**`**，后面的不会再执行。**
+ 如果有父类异常（如 `Exception`），要写在 **最后一个 catch** 中，否则会报错。
+ 正确写法：

```java
try {
    ...
} catch (ArrayIndexOutOfBoundsException e) {
    ...
} catch (Exception e) { // 父类异常写最后
    ...
}
```

3. **多个异常的合并写法**

```java
package com.aurora.ExceptionDemo;

public class try_catch_Demo03 {
    public static void main(String[] args) {
        try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]);
            int result = 10 / 0;
        } catch (ArrayIndexOutOfBoundsException | ArithmeticException e) {
            System.out.println("出现了数组越界或除零异常");
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762666834551-b0b09008-e9c1-46b2-958b-8ecd4d4307cd.png)

4. **正常使用**`**try...catch**`**只能处理一条异常信息，因为只会执行第一个匹配的 **`**catch**`**，后面的不会再执行。那如果想对抛出的多个异常分别处理，怎么办？**
+ 让每个可能出错的语句以及处理方法单独放在一个`try...catch`语句中

### Exception打印异常信息的常用方法
在 `catch` 块中，我们通常会用到以下方法查看异常信息：

| 方法 | 作用 |
| --- | --- |
| `getMessage()` | 获取异常的简要描述 |
| `printStackTrace()` | 打印异常的详细堆栈信息（最常用） |
| `toString()` | 返回异常的类型和描述 |


```java
package com.aurora.ExceptionDemo;

public class ExceptionMethodDemo01 {
    public static void main(String[] args) {
        try {
            int result = 10 / 0;
            System.out.println("result:" + result);
        } catch (ArithmeticException e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            System.out.println(e.toString());
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762666661214-a98947ec-53bc-45bd-9139-fac643d36c98.png)

### 快捷键
将可能出现异常的代码块选中->按住快捷键`ctrl + alt + t`->选中`try-catch`

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762999778375-cb07870b-2ddd-421c-b38d-24cd27dbd4f1.png)

## 使用throws处理异常
1. **throws的作用：**`throws` 用于 在方法声明上，向调用者“抛出”异常，告诉调用者：“我这里可能会出问题，你来处理”。  
2. **语法格式**

```java
修饰符 返回值类型 方法名(参数列表) throws 异常类型1, 异常类型2, ...{
    //可能出现异常的代码
}
```

3. **示例**

```java
package com.aurora.ExceptionDemo;

import java.io.FileReader;
import java.io.IOException;

public class throwsDemo01 {
    public static void main(String[] args) {
        try {
            readFile("test.txt");
        } catch (IOException e) {
            System.out.println("文件读取出错" + e.getMessage());
        }
    }

    public static void readFile(String filePath) throws IOException {
        FileReader fr = new FileReader(filePath);
        fr.close();
    }
}
```

+ 在没有创建`test.txt`文件时的输出结果：

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762667899452-6a2710d4-35bd-4ea0-8c91-b72db00f61a9.png)

说明：

+ `readFile()` 方法声明了 `throws IOException`，意思是它**可能抛出 IO 异常**。
+ 调用者（`main()`）必须处理这个异常，要么 `try...catch`，要么继续 `throws`。  
4. `**throws**`**与**`**try...catch**`**的区别**

| 对比项 | `try...catch` | `throws` |
| --- | --- | --- |
| 位置 | 在方法内部使用 | 在方法声明处使用 |
| 作用 | 自己捕获并处理异常 | 把异常交给调用者处理 |
| 适用场景 | 能确定怎么处理异常 | 暂时无法处理异常或想推给上层 |
| 编译影响 | 编译期不会强制要求外部处理 | 若抛出受检异常，上层必须处理 |
| 示例 | `try { ... } catch (IOException e) {}` | `public void read() throws IOException {}` |


5. **多个异常的声明**

一个方法中可能会产生多个异常。可以声明多个

```java
package com.aurora.ExceptionDemo;

public class throwsDemo02 {
    public static void main(String[] args) {
        try {
            method();
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println(e.toString());
        } catch (ArithmeticException e) {
            System.out.println(e.toString());
        }
    }

    public static void method() throws ArrayIndexOutOfBoundsException, ArithmeticException {
        int[] arr = {1, 2, 3};
        System.out.println(arr[5]);
        int result = 10 / 0;    //不会执行到这里
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762674249853-4e43d522-e3de-4eb6-b7b1-47a749419034.png)

也可以使用一个`catch`合并捕获多个异常

```java
try{
    method();
} catch (ArrayIndexOutOfBoundsException | (ArithmeticException e){
    System.out.println(e.toString());
}
```

## 异常的传递（逐层上抛）
 异常可以一层层传递，直到被某个方法捕获为止。  

```java
package com.aurora.ExceptionDemo;

/*
    异常的传递（逐层上抛）
 */

import java.io.FileReader;
import java.io.IOException;

public class throwsDemo03 {
    public static void main(String[] args) {
        try {
            methodA();
        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println("程序仍在运行");
    }

    public static void methodA() throws IOException{        //继续抛出IOException
        methodB();
    }

    public static void methodB() throws IOException {       //抛出IOException
        FileReader fr = new FileReader("test.txt");
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762675271899-64a1c574-2b5f-41bd-a682-32d6a15a3bac.png)

执行流程：

1. `methodB()` 出现异常并 `throws IOException`
2. `methodA()` 没有处理，所以继续上抛
3. `main()` 捕获异常并处理

## 使用`try...catch...finally`处理异常
1. 基本结构与作用

```java
try {
    // 可能发生异常的代码
} catch (异常类型 变量名) {
    // 捕获并处理异常
} finally {
    // 无论是否有异常，最终都会执行的代码
}
```

2. 作用说明

| 块名 | 作用 |
| --- | --- |
| `try` | 放置可能抛出异常的代码 |
| `catch` | 当 `try`<br/> 中出现异常时，用来捕获并处理 |
| `finally` | **不论是否有异常，最后一定执行**，常用于释放资源（关闭文件、数据库、网络连接等） |




3. **基础示例**

```java
package com.aurora.ExceptionDemo;

public class finallyDemo01 {
    public static void main(String[] args) {
        try {
            int result = 10 / 0;
            System.out.println("result is " + result);
        } catch (ArithmeticException e) {
            System.out.println("捕获异常: " + e.getMessage());
        } finally {
            System.out.println("finally一定会执行");
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762678749060-a60e5376-94bd-47fb-a28b-0aece18f5ed5.png)

4. **finally的常见使用场景**

这里先介绍一个操作文件的场景，实际上还可用于多线程中释放锁等场景，后面学到这些知识点再说。

```java
package com.aurora.ExceptionDemo;

/*
    finally用于操作文件的场景
 */

import java.io.FileReader;
import java.io.IOException;

public class finallyDemo02 {
    public static void main(String[] args) {
        FileReader fr = null;
        try {
            fr = new FileReader("E:\\code\\Java\\JavaSE\\module3\\src\\com\\aurora\\ExceptionDemo\\test.txt");
            //读取文件
        } catch (IOException e) {
            System.out.println("捕获异常：" + e.getMessage());
        } finally {
            try {
                if (fr != null){
                    fr.close();
                    System.out.println("文件已关闭");
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762680113009-9bdc0e94-9346-4a5f-b448-476fb8f5367d.png)

## `try...catch`和`throws`的使用时机
1. 如果处理异常之后,还想让后续的代码正常执行,我们使用try...catch
2. 如果方法之间是递进关系(调用),我们可以先throws,但是到了最后需要用try...catch做一个统一的异常处理

# 继承中抛异常的注意事项
1. 如果父类中的方法抛了异常，那么子类重写后可抛可不抛。
2. 如果父类中的方法没有抛异常，那么子类重写之后不用抛。

# 自定义异常
1. 为什么要自定义异常？

Java 自带的异常（如 `NullPointerException`、`IOException`、`ArithmeticException` 等）主要描述 **系统级错误**。但在业务场景中，我们经常需要描述**业务逻辑错误**，例如：

+ 用户输入的年龄不能小于 0
+ 银行取款金额不能超过余额
+ 登录失败次数超过限制
2. **自定义异常的本质**
+  自定义异常就是定义一个**新的类**，继承自 `Exception` 或 `RuntimeException`。  
+ 如果继承自`Exception`，就是编译时期异常，必须使用`try...catch`或`throws`处理异常
+ 如果继承自`RuntimeException`，就是运行时期异常（逻辑、参数等），可处理可不处理
3. **例子**

:::tips
**需求：**键盘录入一个用户名，实现登录功能，如果登陆失败，抛出LoginUserException

:::

```java
package com.aurora.ExceptionDemo;

public class LoginUserException extends Exception {
    //无参构造
    public LoginUserException() {
    }

    //带有信息的构造
    public LoginUserException(String message) {
        super(message);
    }
}
```

```java
package com.aurora.ExceptionDemo;

import java.util.Scanner;

public class UserLoginTest {
    public static void main(String[] args) throws LoginUserException{
        //定义一个用户名
        String user_name = "root";
        //键盘录入用户名用于登录
        Scanner sc = new Scanner(System.in);
        String login_name = sc.next();
        //判断用户名是否匹配
        try {
            CheckName(user_name, login_name);
        } catch (LoginUserException e) {
            System.out.println("捕获异常" + e.getMessage());
            e.printStackTrace();
        }
    }

    public static void CheckName(String user_name, String login_name) throws LoginUserException{
        if (user_name.equals(login_name)) {
            System.out.println("登陆成功！");
        } else {
            throw new LoginUserException("登陆失败，用户名或密码有问题");
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762682816570-1d2c9d85-4b2c-468d-93cc-9ac71bb40b29.png)

# thorws和throw的区别
![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763001205576-91436602-ecff-4142-bdd5-6ae236c03c2a.png)

`throw`用于手动生成异常对象，例如上面自定义异常的例子，`ChechName`方法体中如果`user_name` 和`login_name`不匹配，则会手动抛出一个异常对象交给调用者处理，即`throw new LoginUserException("登陆失败，用户名或密码有问题");`

# 练习
<font style="color:rgb(31, 35, 40);">编写应用程序，接收命令行的两个参数(整数)，计算两数相除。</font>

<font style="color:rgb(31, 35, 40);">计算两个数相除，要求使用方法 cal(int n1, int n2)</font>

<font style="color:rgb(31, 35, 40);">对数据格式不正确(NumberFormatException)、缺少命令行参数(ArrayIndexOutOfBoundsException)、除0 进行异常处理(ArithmeticException)。</font>

```java
package com.aurora.ExceptionDemo;

public class Practice02 {
    public static void main(String[] args) {

        try {
            if (args.length != 2) {
                throw new ArrayIndexOutOfBoundsException("参数个数不对");
            }

            int n1 = Integer.parseInt(args[0]);
            int n2 = Integer.parseInt(args[1]);

            int result = cal(n1,n2);
            System.out.println("result:"+result);
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println(e.getMessage());
        } catch (NumberFormatException e) {
            System.out.println("参数格式不对，应该输入整数");;
        } catch (ArithmeticException e) {
            System.out.println("除数不能为0");
        }
    }

    public static int cal(int n1, int n2) {
        return n1 / n2;
    }
}
```

+ 测试正确输入以及三种错误输入的结果：

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763003298515-b4b7cc71-516d-4f05-b564-a99406249e85.png)

