# 内部类的概念
1. **定义： **内部类是定义在另一个类内部的类。也就是说，一个类的定义可以嵌套在另一个类中。  
2. **示例**

```java
class Outer {
    class Inner {
        void show() {
            System.out.println("我是内部类");
        }
    }
}
```

3. **什么时候用内部类：**
+ 当一个事物的内部,还有一个部分需要完整的结构去描述,而这个内部的完整结构又只为外部事物提供服务,那么整个内部的完成结构最好使用内部类
+ 比如:人类都有心脏,人类本身需要用属性,行为去描述,那么人类内部的心脏也需要心脏特殊的属性和行为去描述,此时心脏就可以定义成内部类,人类中的一个心脏类
4. **内部类的目的**
+ 让两个类联系更紧密
+ 隐藏实现细节
+ 能更方便的访问外部类的成员
5. **内部类的分类**
+ 成员内部类（静态，非静态）
+ 局部内部类
+ 匿名内部类（重点）
6. **内部类与普通类的区别**

| **项目** | **普通类** | **内部类** |
| --- | --- | --- |
| **访问外部类成员** | 无法访问其他类的私有成员 | 内部类可访问外部类的所有成员（包括 private） |
| **访问修饰符** | 只能是 `public`或无修饰符（包访问） | 可以是 `private`、`protected`<br/>、`public`、默认访问 |
| **创建方式** | `new ClassName()` | `new Outer().new Inner()`<br/>（非静态成员内部类） |


7. **内部类与普通类相同的点**
    1. 内部类可以定义属性、方法、构造等
    2. 可以被 `final` 或 `abstract` 修饰,被`final`修饰之后,不能被继承；被`abstract`修饰之后,不能`new ` 

# 静态成员内部类
1. **格式**：直接在定义内部类的时候加上static关键字

```java
public class A{
    static class B{
        
    }
}
```

2. **创建内部类对象的方式：**
+  静态内部类**不依赖外部类实例**，可以直接创建（即不需要先创建外部类对象）
+ `外部类.内部类 对象名 = new 外部类.内部类`
+ 例如：`A.B b = new A.B`
3. 示例

```java
package com.aurora.InnerClassDemo;

public class Person {
    public void eat(){
        System.out.println("人要吃饭");
    }

    //内部类
    static class Heart{
        public void jump(){
            System.out.println("心脏跳");
        }
    }
}
```

```java
package com.aurora.InnerClassDemo;

public class Test01 {
    public static void main(String[] args) {
        //创建内部类对象
        Person.Heart heart = new Person.Heart();
        heart.jump();
    }
}
```

4. **注意：**静态内部类不能调用外部的非静态成员   
5. **静态内部类的作用**
+  静态内部类可作为工具类或子模块使用

# 非静态成员内部类
1. **概念：**没有使用`static`修饰的内部类
2. **注意：**非静态成员内部类依附于外部类实例，即**必须先创建外部类对象，才能创建内部类对象**（这点注意与静态成员内部类区分）
3. **创建方式**
+ 假设外部类为`Outer`，非静态内部类为`Inner`

```java
Outer outer = new Outer();
Outer.Inner inner  = outer.new Inner();
```

+ 不能这样写

```java
Outer.Inner inner  = new Outer.Inner();		//编译错误
```

4. **实例**

```java
package com.aurora.InnerClassDemo.Demo02;

public class Person {

    //非静态成员内部类
    class Heart{
        public void jump(){
            System.out.println("心脏在跳动");
        }
    }
}
```

```java
package com.aurora.InnerClassDemo.Demo02;

public class Test01 {
    public static void main(String[] args) {
        //需要先创建外部类实例
        Person person = new Person();
        Person.Heart heart = person.new Heart();

        //调用内部类的方法
        heart.jump();
    }
}
```

5. **访问规则**

| 规则 | 说明 |
| --- | --- |
| ✅ 可访问外部类的所有成员（包括 `private`） | 因为内部类**持有外部类对象的引用** |
| ✅ 可访问外部类的静态成员/非静态成员 | 静态成员属于类级别，当然也能访问 |
| ⚠️ 外部类访问内部类 | 需要通过创建对象来实现 |


# 局部内部类
## 局部内部类的基本使用
1. **概念：**定义在一个方法（或代码块）内部的类，它的作用范围仅限于该方法（或代码块）中，在方法外部无法访问
2. 示例

```java
package com.aurora.InnerClassDemo.LocalInnerClass;

public class Outer {

    void display(){
        //定义在方法里的局部内部类
        class LocalInner {
            void show(){
                System.out.println("局部内部类中的show方法");
            }
        }

        //创建局部内部类对象并使用
        LocalInner localInner = new LocalInner();
        localInner.show();
    }
}
```

```java
package com.aurora.InnerClassDemo.LocalInnerClass;

public class Test01 {
    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.display();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762573293638-815a41da-3b6a-4615-a003-540af8792954.png)

## 局部内部类作为实现类
> 与本文档补充知识中的第1节：接口类型作为方法参数和返回值中的`new_Mouse`方法实现方式不同：
>
> + 该文档为了返回`Mouse`类型，并没有单独新建一个文件去写`Mouse`类实现`USB`接口，而是直接在`new_Mouse`方法中使用局部内部类实现了`USB`接口
>

```java
package com.aurora.InnerClassDemo.LocalInnerClass;

public interface USB {
    void open();
}
```

```java
package com.aurora.InnerClassDemo.LocalInnerClass;

/*
    局部内部类作为实现类
 */

public class Test02 {
    public static void main(String[] args) {
        USB mouse = new_Mouse();
        USB_open(mouse);
    }

    //接口作为方法参数传递
    public static void USB_open(USB usb) {
        usb.open();
    }

    //接口作为返回值返回
    public static USB new_Mouse(){
        //直接使用局部内部类实现USB接口
        class Mouse implements USB{
            @Override
            public void open() {
                System.out.println("Mouse open");
            }
        }
        return new Mouse();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762580674004-b25a6421-f470-4fb4-a8c5-d3896663fc1f.png)

## 局部内部类作为子类继承抽象类
> 与上面的局部内部类作为实现类类似，局部内部类作为子类继承抽象类时，也不需要单独新建一个文件去写子类`Dog`，而是可以直接在方法内部使用局部内部类作为子类继承抽象类`Animal`
>

```java
package com.aurora.InnerClassDemo.LocalInnerClass;

public abstract class Animal {
    public abstract void eat();
}
```

```java
package com.aurora.InnerClassDemo.LocalInnerClass;

/*
    局部内部类作为子类继承抽象类
 */

public class Test03 {
    public static void main(String[] args) {
        Animal dog = new_Dog();
        Animal_eat(dog);
    }

    //抽象类作为方法参数传递
    public static void Animal_eat(Animal animal) {
        animal.eat();
    }

    //抽象类作为返回值返回
    public static Animal new_Dog() {
        //直接使用局部内部类作为子类继承抽象类
        class Dog extends Animal{
            @Override
            public void eat() {
                System.out.println("Dog eat");
            }
        }
        return new Dog();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762581509048-863a07ac-fb27-4a0f-ae32-f01363206914.png) 

# 匿名内部类
## 匿名内部类的基本使用
1. **定义：**匿名内部类是一种没有名字的内部类，它在定义的同时创建对象，通常用于**实现接口后实现父类**的一次性需求
2. **使用格式**
+ 格式一

```java
new 父类或接口名(){
    //重写父类/接口方法
}.重写的方法();
```

+ 格式二

```java
类名 对象名 = new 父类或接口名(){
    //重写方法
};
对象名.重写的方法();
```

+ 注意 别忘记最后的`;`
3. **与传统方法的区别**

通常在实现接口时的步骤比较复杂：

    1. 创建实现类，实现接口
    2. 重写方法
    3. 创建实现类对象
    4. 调用方法
4. 使用示例
    1. **匿名内部类实现接口**

```java
package com.aurora.InnerClassDemo.AnonimousInnerClass;

public interface USB {
    void open();
    void close();
}
```

```java
package com.aurora.InnerClassDemo.AnonimousInnerClass;
/*
    匿名内部类使用示例
 */
public class Test01 {
    public static void main(String[] args) {
        USB usb = new USB() {
            @Override
            public void open() {
                System.out.println("USB open");
            }

            @Override
            public void close() {
                System.out.println("USB close");
            }
        };
        usb.open();
        usb.close();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762595240496-e8e4b601-289b-4fcd-b139-ea8658967216.png)

    2. **匿名内部类作为子类继承抽象类**

```java
package com.aurora.InnerClassDemo.AnonimousInnerClass;

public abstract class Animal {
    public abstract void eat();
}
```

```java
package com.aurora.InnerClassDemo.AnonimousInnerClass;

/*
    匿名内部类作为子类继承抽象类
 */

public class Test02 {
    public static void main(String[] args) {
        Animal dog = new Animal() {
            @Override
            public void eat() {
                System.out.println("Dog eat");
            }
        };
        dog.eat();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762595464110-beea1b01-02a7-46dd-8a7c-5f999625a8f3.png)

5. **什么时候使用匿名内部类**
+ 当简单调用一次接口中的方法时，就可以使用匿名内部类

## 匿名内部类当参数传递（实现接口）
```java
package com.aurora.InnerClassDemo.AnonimousInnerClass;

public interface USB {
    void open();
    void close();
}
```

```java
package com.aurora.InnerClassDemo.AnonimousInnerClass;

/*
    匿名内部类当参数传递
 */

public class Test03 {
    public static void main(String[] args) {
        //调用USB_operator函数，匿名内部类作为参数传递
        USB_operator(new USB() {
            @Override
            public void open() {
                System.out.println("Mouse open");
            }

            @Override
            public void close() {
                System.out.println("Mouse close");
            }
        });
    }

    public static void USB_operator(USB usb) {
        usb.open();
        usb.close();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762597840977-2ce165ee-1ea6-42cf-975c-866b671a3aeb.png)

## 匿名内部类作为返回值返回（实现接口）
```java
package com.aurora.InnerClassDemo.AnonimousInnerClass;

public class Test04 {
    public static void main(String[] args) {
        USB mouse = new_Mouse();
        mouse.open();
        mouse.close();
    }

    public static USB new_Mouse(){
        //匿名内部类作为返回值返回
        return new USB() {
            @Override
            public void open() {
                System.out.println("Mouse open");
            }

            @Override
            public void close() {
                System.out.println("Mouse close");
            }
        };
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762597697292-6a074f21-7261-4dd3-9c44-e6fa3b24aef2.png)

## 匿名内部类作为参数传递（继承抽象类）
```java
package com.aurora.InnerClassDemo.AnonimousInnerClass;

public abstract class Animal {
    public abstract void eat();
}
```

```java
package com.aurora.InnerClassDemo.AnonimousInnerClass;

/*
    匿名内部类作为参数传递（作为子类继承接口）
 */

public class Test05 {
    public static void main(String[] args) {
        Animal_eat(new Animal() {
            @Override
            public void eat() {
                System.out.println("Dog eat");
            }
        });
    }

    //匿名内部类作为子类继承抽象类并当作参数传递
    public static void Animal_eat(Animal animal) {
        animal.eat();
    }
}
```

## 匿名内部类作为返回值返回（继承抽象类）
```java
package com.aurora.InnerClassDemo.AnonimousInnerClass;

/*
    匿名内部类作为返回值返回（作为子类继承抽象类）
 */

public class Test06 {
    public static void main(String[] args) {
        Animal dog = new_Dog();
        dog.eat();
    }

    public static Animal new_Dog() {
        return new Animal() {
            @Override
            public void eat() {
                System.out.println("Dog eat");
            }
        };
    }
}

```

# 补充知识
## 接口类型作为方法参数传递和返回
1. **注意：**
+ 接口作为方法参数，传递实参时，传递的是实现类对象
+ 接口作为返回值类型返回，实际返回的也是实现类对象
2. 示例

```java
package com.aurora.InnerClassDemo.Supplement;

public interface USB {
    void open();
}
```

```java
package com.aurora.InnerClassDemo.Supplement;

public class Mouse implements USB {
    @Override
    public void open() {
        System.out.println("鼠标打开");
    }
}
```

```java
package com.aurora.InnerClassDemo.Supplement;

/*
    接口作为参数传递，以及作为返回值返回
 */
public class Test01 {
    public static void main(String[] args) {
        USB mouse = new_Mouse();
        USB_open(mouse);
    }

    //接口作为参数传递
    public static void USB_open(USB usb) {
        usb.open();
    }

    //接口作为返回值返回
    public static USB new_Mouse(){
        return new Mouse();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762579101955-37f221fc-d9c7-41be-8cb5-96814618eb10.png)

## 抽象类作为方法参数和返回值
1. **注意**
+ 抽象类作为方法参数传递，传递实参时，实际上传递的是其子类对象
+ 抽象方法作为方法返回值类型返回时，实际返回的也是其子类对象
2. **示例**

```java
package com.aurora.InnerClassDemo.Supplement;

public abstract class Animal {
    public abstract void eat();
}
```

```java
package com.aurora.InnerClassDemo.Supplement;

public class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("Dog eat");
    }
}
```

```java
package com.aurora.InnerClassDemo.Supplement;
/*
    抽象类作为方法参数和返回值
 */
public class Test02 {
    public static void main(String[] args) {
        Animal dog = new_Dog();
        Animal_eat(dog);
    }

    //抽象类作为方法参数
    public static void Animal_eat(Animal animal) {
        animal.eat();
    }

    //抽象方法作为方法返回值
    public static Animal new_Dog(){
        return new Dog();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762579886784-5524740a-5799-405d-aba4-7a5ad41a9ae1.png)

## 普通类做方法参数和返回值
1. **注意**
+ 普通类做方法参数传递，传递的时对象
+ 普通类作为方法返回值返回，返回的也是对象
2. 示例

```java
package com.aurora.InnerClassDemo.Supplement;

public class Person {
    public void eat(){
        System.out.println("人要吃饭");
    }
}
```

```java
package com.aurora.InnerClassDemo.Supplement;

/*
    普通类作为方法参数以及返回值
 */
public class Test03 {
    public static void main(String[] args) {
        Person person = new_Person();
        Person_eat(person);
    }

    //普通类作为方法参数传递
    public static void Person_eat(Person person) {
        person.eat();
    }

    //普通类作为返回值返回
    public static Person new_Person() {
        return new Person();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762580321148-bf5ceb2c-8616-4f55-88b2-9743a43fc89a.png)

