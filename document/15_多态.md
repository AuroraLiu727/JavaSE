# 多态的介绍
## 多态的定义及示例
1. **定义**：**多态指同一个行为（方法）在不同对象上有不同的表现形式**，即父类引用指向子类对象使，调用的方法表现出不同的实现效果
2. **实现多态的前提**
+ **继承（或实现）**：子类继承父类或实现接口；
+ **方法重写（Override）**：子类重写父类中的方法；
+ **父类引用指向子类对象**：`Parent p = new Child();`
    - “父类引用” 负责提供 **统一的调用入口**；
    - “子类对象” 负责提供 **各自的具体实现**。
3. **示例**

```java
package com.aurora.Polymorphism.Demo01;

public class Vehicle {
    void run(){
        System.out.println("交通工具在运行");
    }
}
```

```java
package com.aurora.Polymorphism.Demo01;

public class Car extends Vehicle {
    @Override
    void run() {
        System.out.println("汽车在行驶");
    }
}
```

```java
package com.aurora.Polymorphism.Demo01;

public class Bike extends Vehicle {
    @Override
    void run() {
        System.out.println("自行车在骑行");
    }
}
```

```java
package com.aurora.Polymorphism.Demo01;

public class Test {
    public static void main(String[] args) {
        //多态形式的new对象
        Vehicle a1 = new Car();  // Car，但被当成Vehicle大类看
        Vehicle a2 = new Bike();  //Bike ，但被当成Vehicle大类看

        a1.run();
        a2.run();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762182604997-0582cbf8-cc2c-447a-ad80-1700b51edbed.png)

+ **虽然调用的都是**`**run()**`**，但是输出不同，这就是多态**
4. **编译期与运行期的区别**
+ **编译期看左边**（变量声明类型），上例中， `v1` 和 `v2` 的“编译时类型”都是 `Vehicle`
+ **运行期看右边**（对象实际类型），上例中：
    - `v1` 的运行时类型是 `Car`
    - `v2` 的运行时类型是 `Bike`

## 为什么要有多态
+ **没有多态时：** 每种交通工具都得写一个方法，因为参数类型不一致（`Car car`,`Bike bike`），很麻烦。  

```java
void drive(Car car) { car.run(); }
void drive(Bike bike) { bike.run(); }
```

+ **有了多态后：** 无论传入的是汽车、自行车、摩托车……  ， 都能自动调用正确的 `run()` 方法。  
    - 因为在多态的前提中有一条：**父类引用指向子类对象**：`Parent p = new Child();`，所以本例在定义时有`Vehicle car = new Car();`、`Vehicle bike = new Bike();`，声明出来的都是`Animal`类型，但真正执行时， Java 会根据右边“对象的实际类型”去找对应的方法。

```java
void drive(Vehicle vehicle) { vehicle.run(); }
```

```java
package com.aurora.Polymorphism.Demo01;

public class Test {

    public static void drive(Vehicle vehicle) {
        vehicle.run();
    }
    public static void main(String[] args) {
        //多态形式的new对象
        Vehicle a1 = new Car();  // Car，但被当成Vehicle大类看
        Vehicle a2 = new Bike();  //Bike ，但被当成Vehicle大类看

//        a1.run();
//        a2.run();

        drive(a1);
        drive(a2);

    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762183640947-fe84e9b3-0c28-4ff1-a3f1-ce6a92758880.png)

# 多态条件下成员变量和成员方法访问的特点
1. Java多态中的**编译时类型vs运行时类型**

| 名称 | 是什么 | 在哪里决定 | 用来干嘛 |
| --- | --- | --- | --- |
| **编译时类型** | 变量声明时写的类型（左边） | 编译阶段 | 决定你**能调用哪些方法**（只是判断有没有这个方法） |
| **运行时类型** | 实际创建的对象类型（右边） | 程序运行时 | 决定**真正执行哪个方法** |


2. Java多态中**成员变量&成员方法**的决定方式

| 成员类型 | 看谁决定 | 说明 |
| --- | --- | --- |
| **成员变量** | 看左边（编译时类型 / 父类） | 编译和运行都看父类 |
| **成员方法** | 看右边（运行时类型 / 子类） | 编译看父类，运行看子类 |


3. 示例

```java
package com.aurora.Polymorphism.Demo02;

public class Parent {
    int num = 10;

    void show(){
        System.out.println("父类的show()");
    }
}
```

```java
package com.aurora.Polymorphism.Demo02;

public class Child extends Parent{
    int num =  20;

    @Override
    void show() {
        System.out.println("子类的show()");
    }
}
```

```java
package com.aurora.Polymorphism.Demo02;

public class Test {
    public static void main(String[] args) {
        //多态
        Parent p = new Child();

        //调用成员变量
        System.out.println(p.num);

        //调用成员方法
        p.show();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762225171640-dd537e66-51a5-4df4-be49-6ba1e7abfc3f.png)

**分析：**

+ `p.num` ——访问成员变量，看左边（父类）
    - 编译时：编译器只知道 `p` 是 `Parent` 类型；
    - 运行时：依然访问 `Parent` 的 `num`；
    - 所以输出 `10`。
    -  <font style="color:#117CEE;">变量不具备多态性，</font>**<font style="color:#117CEE;">不会动态绑定</font>**<font style="color:#117CEE;">。  </font>
+ `p.show()` ——调用成员方法，看右边（子类）  
    - 编译时：检查父类里有没有 `show()` 方法（有，OK）；
    - 运行时：真正执行的是 `Child` 的重写方法；
    - 所以输出 `子类的 show()`。
    - <font style="color:#117CEE;">方法具有多态性，</font>**<font style="color:#117CEE;">运行时动态绑定</font>**<font style="color:#117CEE;">。</font>
4. **为什么有这种区别**
+ **成员变量**是**静态绑定**（编译时就确定内存位置），所以只能访问“编译时类型”的变量。
+ **成员方法**是**动态绑定**（运行时决定执行哪个版本），所以会根据实际对象类型来调用子类方法。
5. **注意：多态不能直接调用子类的特有功能**

```java
package com.aurora.Polymorphism.Demo02;

public class Child extends Parent{
    int num =  20;

    @Override
    void show() {
        System.out.println("子类的show()");
    }

    //给上例加一个子类特有的方法
    void special(){
        System.out.println("子类的特有方法");
    }
}
```

```java
package com.aurora.Polymorphism.Demo02;

public class Test {
    public static void main(String[] args) {
        //多态
        Parent p = new Child();

        //调用成员变量
        System.out.println(p.num);

        //调用成员方法
        p.show();

        //不能调用子类的特有方法
        //p.special();  //报错
    }
}
```

+ 直接调用`p.special()`会报错
6. **总结**
+ **变量看左边，方法看右边**
+ **编译看父类，运行看子类**

# 多态中的转型
1. 定义：即父类与子类之间相互转换的操作。
2. 分类

| 转型类型 | 说明 | 示例 | 是否安全 |
| --- | --- | --- | --- |
| 向上转型（Upcasting） | 子类 → 父类 | `Animal a = new Dog();` | ✅ 安全，自动完成 |
| 向下转型（Downcasting） | 父类 → 子类 | `Dog d = (Dog) a;` | ⚠️ 不一定安全，需判断 |


## 向上转型（子类→父类）
**自动完成，无需强制转换**

```java
package com.aurora.Polymorphism.Demo01;

public class Test02 {
    public static void main(String[] args) {
        //向上转型
        Car car = new Car();
        Vehicle v1 = car;   //向上转型
        car.run();          //调用Car的run()，体现多态
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762233056901-05e96d22-d09a-46f9-b2df-b8fd52a5e2dc.png)

+ 编译类型：`Vehicle`
+ 运行类型：`Car`
+ 特点：  
✅ 只能调用父类中定义的方法；  
✅ 执行的是子类重写的方法（体现多态）。
+ `Car car = new Car();`和`Vehicle v1 = car;`两句等价于`Vehicle v1 = new Car();`

## 向下转型
**需要强制转换，编译器不会自动做。**

```java
package com.aurora.Polymorphism.Demo01;

public class Test02 {
    public static void main(String[] args) {

        //向下转型
        Vehicle v2 = new Car();
        Car c = (Car) v2;	//向下转型
        c.run();	//依旧是调用子类的方法
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762233306728-929f7f5a-fc70-44b7-86a6-4a3b70e985c0.png)

### 向下转型后调用子类特有方法
+ **前面讲的多态中不能直接调用子类的特有功能，但是如果向下转型之后，就可以调用子类的特有方法了**
    - 比如现在在子类`Car`中写入一个特有方法`special`

```java
package com.aurora.Polymorphism.Demo01;

public class Car extends Vehicle {
    @Override
    void run() {
        System.out.println("汽车在行驶");
    }
    
    //子类的特有方法
    void special(){
        System.out.println("子类的特有方法");
    }
}
```

```java
package com.aurora.Polymorphism.Demo01;

public class Test02 {
    public static void main(String[] args) {

        //向下转型
        Vehicle v = new Car();
        Car c = (Car) v;
        c.run();
        //v2.special();     //向下转型之前不能直接调用子类的特有方法
        c.special();        //向下转型之后可以调用子类的特有方法
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762233661274-5c4e9174-2d31-4dfd-be6f-b267ba6ce491.png)

### 预防转型异常
上例中，将`v`强转成`Car`类型时是正确的，但如果`v`的实际类型不是`Car`，就会抛出  
`ClassCastException`异常，例如：

```java
Vehicle v = new Bike();
Car c = (Car) v;
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762234702997-bc34d09a-50d1-44f9-b1e5-b68cfbe90948.png)

**这时候可以使用**`**instanceof**`**关键字判断类型**

```java
package com.aurora.Polymorphism.Demo01;

public class instanceofDemo {
    public static void main(String[] args) {
        //类型正确时
        System.out.println("================类型正确时================");
        Vehicle v1 = new Car();
        if (v1 instanceof Car){
            Car c1 = (Car) v1;
            c1.run();
        } else {
            System.out.println("不是Car类型，不能转型");
        }

        //类型不正确时
        System.out.println("================类型不正确时=================");
        Vehicle v2 = new Bike();
        if (v2 instanceof Car){
            Car c2 = (Car) v2;
            v2.run();
        } else {
            System.out.println("不是Car类型，不能转型");
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762234583774-3d4288b0-7b64-4e7c-8341-dc07cfd4754b.png)

