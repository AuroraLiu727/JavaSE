# 接口的介绍
![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1761652182534-55b6b0bf-dc99-488e-8405-5678971a5cf8.png)

# 接口的定义及使用
1. **定义**： 接口是一种**完全抽象**的类型，用来定义类必须具备的行为规范。接口本身**不实现逻辑**，只声明方法，让实现类去实现。  
2. 关键字
    1. 接口：`interface`；
    2. 定义接口：`public interface 接口名{}`
3. **接口中可以定义的成员**

| **jdk版本** | **可定义的成员** |
| --- | --- |
| jdk7及之前 | + **抽象方法**: `public abstract ` -> 即使不写`public abstract`,默认也有<br/>+ **成员变量**:`public static final` 数据类型 变量名 = 值-> 即使不写`public static final`,默认也有（`final`是最终的,被`final`修饰的变量不能二次赋值,所以我们一般将final修饰的变量视为常量） |
| jdk8 | + 默认方法:`public default` 返回值类型 方法名(形参){}<br/>+ 静态方法:`public static` 返回值类型 方法名(形参){} |
| jdk9 | + 私有方法:`private`的方法 |


4. 接口示例

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1761653581634-73cefa1b-2f85-4b63-9381-fdf937d88711.png)

创建时选择`Interface`，而不是`class`

```java
package com.aurora.interfaceDemo;

public interface USB {
    public abstract void open();
    public abstract void close();
}
```

# 实现类实现接口
1. 定义实现类
    1. 实现：`implements`；
    2. 定义实现类（按照接口的规则实现具体逻辑的类）：`public class 实现类类名 implements 接口名{}`
2. **使用流程**
    1. 实现类实现接口
    2. 在实现类中重写接口中的抽象方法
    3. 创建实现类对象
    4. 调用重写的方法
3. 示例

实现上面的`USB`接口

+ **实现类**

```java
package com.aurora.interfaceDemo;

public class Mouse implements USB{
    @Override
    public void open() {
        System.out.println("鼠标打开");
    }

    @Override
    public void close() {
        System.out.println("鼠标关闭");
    }
}

```

+ **测试类**

```java
package com.aurora.interfaceDemo;

public class Test01 {
    public static void main(String[] args) {
        Mouse mouse = new Mouse();
        mouse.open();
        mouse.close();
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1761653798783-9ad069d6-877a-492e-b8da-eeabfc960cba.png)

# 接口中的成员
## 抽象方法
1. 定义格式：`public abstract 返回值类型 方法名(形参);`
2. 注意：不写`public abstract`默认也有，即可以直接简写成`返回值类型 方法名(形参);`
3. **使用**
    1. 定义实现类，实现接口
    2. 重写抽象方法
    3. 创建实现类对象，调用重写的方法
4. 实现：见1.3中的例子

## 默认方法
1. **为什么要有默认方法？**
+ 在 **Java 8 之前**，接口中的所有方法都是抽象的（`abstract`），也就是说：只要接口新增一个方法，所有实现这个接口的类都必须修改并实现它。 这样很麻烦，会破坏兼容性。 
+ 如果接口中新增的默认方法（**默认方法可以不重写**），就可以避免这种问题
2. 格式：`public default 返回值类型 方法名(参数列表){}`
3. 使用
    1. 定义实现类，实现接口
    2. 重写/不重写抽象方法
    3. 创建实现类对象，调用默认方法
4. 示例
+ **接口(USB)：在上例的USB中加入了一个默认方法**

```java
package com.aurora.interfaceDemo;

public interface USB {
    //抽象方法
    public abstract void open();
    public abstract void close();
    //默认方法
    public default void method_default(){
        System.out.println("我是默认方法");
    }
}

```

+ **实现类（Mouse）：这里并没有重写新加入的默认方法**

```java
package com.aurora.interfaceDemo;

public class Mouse implements USB{
    @Override
    public void open() {
        System.out.println("鼠标打开");
    }

    @Override
    public void close() {
        System.out.println("鼠标关闭");
    }
}
```

+ **测试类**

```java
package com.aurora.interfaceDemo;

public class Test01 {
    public static void main(String[] args) {
        Mouse mouse = new Mouse();
        mouse.open();
        mouse.close();
        //默认方法
        mouse.method_default();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1761977585928-a09d2dba-68d0-4be2-9c71-6439f4b1c6ce.png)

## 静态方法
1. **作用：**类似普通类中的工具方法，可以直接`类名.方法名()`调用，不需要`new`对象
2. 定义格式：`public static 返回值类型 方法名(参数列表){}`
3. 使用方式：`接口名.方法名()`
4. 示例
+ **接口**

```java
package com.aurora.interfaceDemo;

public interface USB {
    //抽象方法
    public abstract void open();
    public abstract void close();

    //默认方法
    public default void method_default(){
        System.out.println("我是默认方法");
    }

    //静态
    public static void method_static(){
        System.out.println("我是静态方法");
    }
}

```

+ **测试类**

```java
package com.aurora.interfaceDemo;

public class Test01 {
    public static void main(String[] args) {
        ////抽象方法使用
        Mouse mouse = new Mouse();
        mouse.open();
        mouse.close();

        //默认方法使用
        mouse.method_default();

        //静态方法使用
        USB.method_static();
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1761978571165-c154a647-b6ef-466d-af97-e20907daa45e.png)

## 成员变量
1. 格式：`public static final 数据类型 变量名 = 值`
2. `final`：代表最终的，被它修饰的变量，不能二次赋值，可以视为常量
3. 特点：`public static final`默认也有，即接口中的成员变量为常量
4. 使用：接口名直接调用
5. 注意：
+ 被`static final`修饰的成员变量需要手动赋值
+ 习惯上将`static final`修饰的成员变量名大写
6. 使用

```java
package com.aurora.interfaceDemo;

public interface USB {
    //成员变量
    public static final int NUM1 = 10;
    int NUM2 = 20;  //不写public static final默认也有
}
```

```java
package com.aurora.interfaceDemo;

public class Test01 {
    public static void main(String[] args) {
        //成员变量使用
        System.out.println(USB.NUM1);
        System.out.println(USB.NUM2);
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1761979866066-be685ea8-c1b8-4fcc-a355-3dc1e811785b.png)

# 接口的特点
## 接口的多继承
1. 定义：一个接口可以继承多个接口

```java
public interface A extends B, C{}
```

2. 注意
+ 接口与类不同，因为接口中没有具体实现，所以不会出现父类方法冲突等问题，因此可以多继承
3. 示例

```java
package com.aurora.interfaceDemo;

public interface A {
    void method_A();
}
```

```java
package com.aurora.interfaceDemo;

public interface B {
    void method_B();
}
```

```java
package com.aurora.interfaceDemo;

public interface C extends A, B{	//多继承
    void method_C();
}
```

4. 接口多继承中的`default`方法重名冲突
+  从 Java 8 起，接口可以有 `default` 方法，这时如果两个父接口有同名默认方法，子接口必须**解决冲突**：  

```java
package com.aurora.interfaceDemo;

public interface A {
    void method();
    
    default void method_default(){
        System.out.println("接口A中的默认方法");
    }
}
```

```java
package com.aurora.interfaceDemo;

public interface B {
    void method();
    
    default void method_default(){
        System.out.println("接口B中的默认方法");
    }
}
```

```java
package com.aurora.interfaceDemo;

public interface C extends A, B{
    void method_C();

    //需要重写重名的默认方法
    @Override
    default void method_default() {
        A.super.method_default();   //指定使用接口A中的抽象方法
    }
}
```

## 接口的多实现
1. 定义：一个实现类可以实现一个或者多个接口

```java
public class MyClass implements A, B{}
```

2. 注意
+ 必须实现所有接口中的抽象方法
+ 若实现类是抽象类，可以不用全部实现
+ **当一个类实现多个接口时，如果接口中的抽象方法有重名且参数一样的，只需要重写一次**
3. 接口多实现中的`default`方法重名冲突
+ 在实现类中重写重名的默认方法
4. 示例（普通方法与默认方法冲突的解决）

```java
package com.aurora.interfaceDemo;

public interface A {
    void method();

    default void method_default(){
        System.out.println("接口A中的默认方法");
    }
}
```

```java
package com.aurora.interfaceDemo;

public interface B {
    void method();

    default void method_default(){
        System.out.println("接口B中的默认方法");
    }
}
```

```java
package com.aurora.interfaceDemo;

public class Implement_class implements A,B {
    //接口A,B中有重名且参数列表相同的的method()方法，只需重写一次
    @Override
    public void method() {
        System.out.println("重写的method方法");
    }

    //在实现类中重写冲突的默认方法
    @Override
    public void method_default() {
        System.out.println("重写后的默认方法");
    }
}
```

```java
package com.aurora.interfaceDemo;

public class Test02 {
    /*
        测试Implement_class
     */
    public static void main(String[] args) {
        Implement_class impl = new Implement_class();
        impl.method();
        impl.method_default();
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1761985175151-e36eed6a-f229-4387-ba37-dedfd7522bc8.png)

## 接口多继承+类多实现的组合
```java
package com.aurora.interfaceDemo.multiExtends_multiImplements;

public interface A {
    void method_A();
}
```

```java
package com.aurora.interfaceDemo.multiExtends_multiImplements;

public interface B {
    void method_B();
}
```

```java
package com.aurora.interfaceDemo.multiExtends_multiImplements;

public interface C extends A, B{
    void method_C();
}
```

```java
package com.aurora.interfaceDemo.multiExtends_multiImplements;

public class ImplementsDemo implements C{
    @Override
    public void method_C() {
        System.out.println("method_C");
    }

    @Override
    public void method_A() {
        System.out.println("method_A");
    }

    @Override
    public void method_B() {
        System.out.println("method_B");
    }
}
```

+ 在实现类中实现了所继承的接口`C`中的方法`method_C()`，也间接实现了接口`C`从接口`A`和接口`B`中继承来的方法`method_A()`和`method_B()`

```java
package com.aurora.interfaceDemo.multiExtends_multiImplements;

public class Test01 {
    public static void main(String[] args) {
        ImplementsDemo impl = new ImplementsDemo();
        impl.method_A();
        impl.method_B();
        impl.method_C();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1761985801180-495c30d8-af5b-42b8-ae6b-408f712c173f.png)

## 继承父类+实现接口
1. 定义：一个子类可以在继承一个父类的同时实现一个或多个接口

```java
public class Zi extends Fu implements A, B{}
```

2. 示例

```java
package com.aurora.interfaceDemo.ClassExtends_multiImplements;

public class Fu {
    public void method_Fu(){
        System.out.println("method_Fu");
    }
}
```

```java
package com.aurora.interfaceDemo.ClassExtends_multiImplements;

public interface InterfaceA {
    void method_InterfaceA();
}
```

```java
package com.aurora.interfaceDemo.ClassExtends_multiImplements;

public interface InterfaceB {
    void method_InterfaceB();
}
```

```java
package com.aurora.interfaceDemo.ClassExtends_multiImplements;

public class Zi extends Fu implements InterfaceA, InterfaceB{
    //重写接口InterfaceA, InterfaceB中的抽象方法

    @Override
    public void method_InterfaceA() {
        System.out.println("method_InterfaceA");
    }

    @Override
    public void method_InterfaceB() {
        System.out.println("method_InterfaceB");
    }

    //子类自己的方法
    public void method_Zi(){
        System.out.println("method_Zi");
    }
}
```

```java
package com.aurora.interfaceDemo.ClassExtends_multiImplements;

public class Test01 {
    public static void main(String[] args) {
        Zi zi = new Zi();
        zi.method_Zi();     //子类自己的方法
        zi.method_Fu();     //从父类继承来的方法
        zi.method_InterfaceA();     //实现InterfaceA时重写的InterfaceA里的抽象方法
        zi.method_InterfaceB();     //实现InterfaceB时重写的InterfaceB里的抽象方法
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1761986861582-6c897304-01a5-4783-b0bb-d8a874752072.png)

# 接口和抽象类的区别
1. 相同点
    1. 都位于继承体系的顶端,用于被其他类实现或者继承
    2. 都不能new
    3. 都包含抽象方法,其子类或者实现类都必须重写这些抽象方法
2. 不同点
    1. 抽象类:一般作为父类使用,可以有成员变量,构造,成员方法,抽象方法等
    2. 接口:成员单一,一般抽取接口,抽取的都是方法,视为功能的大集合
    3. 类不能多继承,但是接口可以

