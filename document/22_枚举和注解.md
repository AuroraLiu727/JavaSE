# 枚举
## 先看一个需求
要求创建季节（Season）对象，设计并完成，下面是一个设计类的常用方式：

```java
class Season{
    private String name;
    private String desc;	//	描述

    //构造器

    //getXX

    //setXX
}
```

但是会出现这样的问题，对于季节

+ 季节的值是有限的四个值(spring, summer, autumn, winter)
+ 只读，不需要修改，即不能出现`autumn.setName("XXX")`的情况

因此需要采用**枚举类**来解决这个问题。

## 枚举的介绍
1. 概述
+ 枚举对应英文（enumeration，简写enum）
+ 枚举是一组常量的集合
+ 可以这么理解：枚举是一种特殊的类，里面只包含一组有限的特定的对象
2. 枚举的两种实现方式
+ 自定义实现枚举
+ 使用`enum`关键字实现枚举

## 自定义实现枚举
1. 核心要点
+ 构造器私有化（防止外部new对象）
+ 类内部创建固定对象（表示所有枚举值）
+ 用`public static final`修饰这些对象（保证唯一、不可变）
+ 可以提供get方法，但是不能提供set方法
+ 枚举对象名通常使用全部大写，常量的命名规范
+ 枚举对象根据需要，也可以有多个属性
2. 示例

```java
package com.aurora.enum_;

public class Season {
    private String name;
    private String desc;    //描述

    //私有的构造方法
    private Season(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    //创建枚举对象
    public static final Season SPRING = new Season("春天", "温暖");
    public static final Season SUMMER = new Season("夏天", "炎热");
    public static final Season AUTUMN = new Season("秋天", "凉爽");
    public static final Season WINTER = new Season("冬天", "寒冷");

    //提供get方法

    public String getName() {
        return name;
    }

    public String getDesc() {
        return desc;
    }

    //重写toString方法
    @Override
    public String toString() {
        return "Season{" +
                "name='" + name + '\'' +
                ", desc='" + desc + '\'' +
                '}';
    }
}
```

```java
package com.aurora.enum_;

public class Test01 {
    public static void main(String[] args) {
        System.out.println(Season.SPRING);
        System.out.println(Season.SUMMER);
        System.out.println(Season.AUTUMN);
        System.out.println(Season.WINTER);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762752321357-4850d369-82e0-48cc-aaa3-c536f2547c69.png)

3. 注意：在测试类中并没有`new`对象，而是直接调用。这是因为在`Season`类中，已经创建好了四个枚举对象， 所以后面我们只是在**直接访问类中已存在的对象引用**。而且它是 public static final 修饰的：
+ `static`：**表示这是属于类本身的对象，类加载时就创建，不需要 new。**
+ `final`：表示引用不可改变，确保唯一。
+ `public`：外部可以直接访问。

这也是设计模式中的饿汉模式： 在类加载时就创建对象实例，不管以后用不用，先创建再说。 

## enum关键字实现枚举
### enum的介绍及使用
1. enum介绍：`enum` 是一种特殊的类（继承自 `java.lang.Enum`），用来表示 **一组固定的常量对象**。  
2. 如何使用enum实现枚举类
    1. 使用关键字`enum`代替`class`
    2. 直接使用`SPRING("春天", "温暖")`代替`public static final Season SPRING = new Season("春天", "温暖");`
        1. 如果使用的是无参构造，甚至可以省略括号，直接写`SPRING, SUMMER, AUTUMN, WINTER`
    3. 如果有多个常量（对象），使用`,`间隔即可，最后用一个分号结尾。
    4. 如果使用`enum`来实现枚举，**要求将定义的常量对象写在最前面，否则会报错**
3. 示例

```java
package com.aurora.enum_;

enum Season {
    SPRING("春天", "温暖"), SUMMER("夏天", "炎热"), AUTUMN("秋天", "凉爽"),
    WINTER("冬天", "寒冷");

    String name;
    String desc;

    private Season() {
    }

    private Season(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    public String getName() {
        return name;
    }

    public String getDesc() {
        return desc;
    }

    @Override
    public String toString() {
        return "Season{" +
                "name='" + name + '\'' +
                ", desc='" + desc + '\'' +
                '}';
    }
}
```

```java
package com.aurora.enum_;

public class Test01 {
    public static void main(String[] args) {
        System.out.println(Season.SPRING);
        System.out.println(Season.SUMMER);
        System.out.println(Season.AUTUMN);
        System.out.println(Season.WINTER);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762760941953-af8c5674-7a0b-48a5-a38b-d04c87f46ba9.png)

### enum枚举的本质
JVM在编译以下代码时：

```java
public enum Season { SPRING, SUMMER, AUTUMN, WINTER }
```

实际上会自动生成一个类似的类（而且是一个final类）：

```java
public final class Season extends Enum<Season> {
    public static final Season SPRING = new Season("SPRING", 0);
    public static final Season SUMMER = new Season("SUMMER", 1);
    public static final Season AUTUMN = new Season("AUTUMN", 2);
    public static final Season WINTER = new Season("WINTER", 3);

    private Season(String name, int ordinal) {
        super(name, ordinal);
    }

    public static Season[] values() { ... }      // 返回所有枚举对象
    public static Season valueOf(String name) { ... } // 按名称获取对象
}
```

也就是说：

+ 每个枚举值其实是 `Season` 类的静态常量对象；
+ 构造器自动私有化；
+ JVM 自动帮你生成常用方法。

### enum常用方法
![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762761800503-55c9a984-f167-4f36-b0e0-0ff6a20ad4d8.png)

```java
package com.aurora.enum_;

//演示enum的各种方法

public class enumMethod {
    public static void main(String[] args) {
        Season season = Season.AUTUMN;

        //1. 输出枚举对象的名字
        System.out.println("枚举对象的名字：" + season.name());  //注意是name()，如果写成name输出的是AUTUMN的name属性

        //2. 输出枚举对象的次序/编号，从0开始编号,AUTUMN枚举对象时第三个，因此输出2
        System.out.println("枚举对象的编号：" + season.ordinal());

        //3.values()方法，返回所有对象的数组
        Season[] values = Season.values();
        System.out.println("==========遍历取出枚举对象（增强for循环）==============");
        for (Season s : values) {
            System.out.println(s);
        }

        //4. compareTo()方法：比较两个枚举对象,返回的是两个枚举对象编号之差
        System.out.println("枚举对象编号之差：" + Season.AUTUMN.compareTo(Season.WINTER));
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762763554580-355e75c2-01bb-46d1-864e-9c5565f022fc.png)

**补充知识：增强for循环**

```java
package com.aurora.enum_;

public class StrengthFor {
    public static void main(String[] args) {
        int[] nums = {1, 2, 3};

        System.out.println("普通for循环");
        //普通for循环
        for (int i = 0; i < nums.length; i++) {
            System.out.println(nums[i]);
        }

        System.out.println("增强for循环");
        //增强for循环
        for (int i : nums) {
            System.out.println(i);
        }
    }
}
```

+ 执行流程是依次从`nums`中取出数据，赋值给i，如果取出完毕，则退出for

### enum实现接口
1. 使用enum关键字后，就不能再继承其他类了，因为enum会隐式继承Enum，而Java是单继承机制
2. 枚举类和普通类一样，可以实现接口
3. 格式

```java
enum 类名 implements 接口1, 接口2{}
```

4. 示例

```java
package com.aurora.enum_;

public enum Season2 implements Info{

    SPRING("春天", "温暖"),
    SUMMER("夏天", "炎热"),
    AUTUMN("秋天", "凉爽"),
    WINTER("冬天", "寒冷");

    private String name;
    private String desc;

    private Season2(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    //重写接口中的方法
    @Override
    public void show() {
        System.out.println(name + "的特点是" + desc);
    }
}
```

```java
package com.aurora.enum_;

public class Test02 {
    public static void main(String[] args) {
        
        //调用重写后的方法
        Season2.AUTUMN.show();
    }
}
```

# 注解（Annotation）
## 注解的概念
1. <font style="color:rgb(31, 35, 40);">注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。</font>
2. <font style="color:rgb(31, 35, 40);">和注释一样，注解不影响程序逻辑，但</font>**<font style="color:rgb(31, 35, 40);">注解可以被编译或运行</font>**<font style="color:rgb(31, 35, 40);">，相当于嵌入在代码中的补充信息。</font>
3. <font style="color:rgb(31, 35, 40);">在JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替java EE 旧版中所遗留的繁冗代码和XML 配置等。</font>

## 基本的Annotation介绍
<font style="color:rgb(31, 35, 40);">使用Annotation 时要在其前面增加 @ 符号, 并把该Annotation 当成一个修饰符使用。用于修饰它支持的程序元素。</font>

<font style="color:rgb(31, 35, 40);">三个基本的Annotation:</font>

1. `<font style="color:rgb(31, 35, 40);">@Override</font>`<font style="color:rgb(31, 35, 40);">: 限定某个方法，是重写父类方法, 该注解只能用于方法。</font>
2. `<font style="color:rgb(31, 35, 40);">@Deprecated</font>`<font style="color:rgb(31, 35, 40);">: 用于表示某个程序元素(类, 方法等)已过时。</font>
3. `<font style="color:rgb(31, 35, 40);">@SuppressWarnings</font>`<font style="color:rgb(31, 35, 40);">: 抑制编译器警告。</font>

## 基本的Annotation应用案例
### @Override
1. 概述：`@Override`表示指定重写父类的方法（从编译层面验证），如果父类没有这个方法，则会报错
2. 注意
+ `@Override`只能修饰方法，不能修饰其他类、包、属性等。
+ 如果不写`@Override`，只要父类有这个方法，仍然构成重写
3. `@Override`的源码

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
```

+ 查看`@Override`注解的源码，发现是`<font style="background-color:rgba(255, 255, 255, 0);">@Target(ElementType.METHOD)</font>`<font style="background-color:rgba(255, 255, 255, 0);">，说明只能修饰方法，</font>`<font style="background-color:rgba(255, 255, 255, 0);">@Target</font>`<font style="background-color:rgba(255, 255, 255, 0);">是修饰注解的注解，成为元注解</font>
+ `<font style="background-color:rgba(255, 255, 255, 0);">@Retention</font>`<font style="background-color:rgba(255, 255, 255, 0);">也是一个元注解，用来说明注解在什么阶段有效，</font>`<font style="background-color:rgba(255, 255, 255, 0);">@Retention(RetentionPolicy.SOURCE)</font>`<font style="background-color:rgba(255, 255, 255, 0);">表示</font>`<font style="background-color:rgba(255, 255, 255, 0);">@Override</font>`<font style="background-color:rgba(255, 255, 255, 0);">只在源码阶段有效，编译成</font>`<font style="background-color:rgba(255, 255, 255, 0);">.class</font>`<font style="background-color:rgba(255, 255, 255, 0);">文件后就会被编译器丢弃</font>
+ 第三行中的`@interface`不是`interface`接口，它是定义注解的关键字

### @Deprecated
1. 作用：`@Deprecated` 用来标记一个**类、方法或字段已过时**，提示开发者不推荐使用（可能被替代或有风险）。  `@Deprecated`可以做到新旧版本的兼容和过渡
2. 使用场景：修饰方法、类、字段、包、参数等等。从源码也能看出`<font style="background-color:rgba(255, 255, 255, 0);">@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})</font>`
3. 示例

```java
package com.aurora.Annotaion;

public class Demo {

    /**
     * @Deprecated 请使用{@link #new_method()}代替
     */
    @Deprecated
    public void old_method(){
        System.out.println("老方法");
    }

    public void new_method(){
        System.out.println("新方法");
    }
}
```

```java
package com.aurora.Annotaion;

public class DeprecatedDemo {

    public static void main(String[] args) {

        Demo demo = new Demo();
        demo.old_method();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762948693495-92a1cedc-5f04-4878-b3de-7244e6a1ec34.png)

+ **调用时会有删除线提示**

### @SuppressWarning
1. 作用： 用于**告诉编译器忽略特定的警告信息**。  例如：未检查的类型转换、未使用的变量、过时方法调用等。
2. 使用方式：`<font style="background-color:rgba(255, 255, 255, 0);">@SuppressWarnings("")</font>`<font style="background-color:rgba(255, 255, 255, 0);">，传入参数，例如</font>`<font style="background-color:rgba(255, 255, 255, 0);">@SuppressWarnings("unchecked")</font>`<font style="background-color:rgba(255, 255, 255, 0);">；也可以传入多个参数，例如</font>`<font style="background-color:rgba(255, 255, 255, 0);">@SuppressWarnings({"rawtypes", "unchecked", "unused"})</font>`
3. 可以修饰的程序元素：`<font style="background-color:rgba(255, 255, 255, 0);">@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})</font>`
4. **<font style="background-color:rgba(255, 255, 255, 0);">常用警告类型</font>**

| 参数值 | 说明 |
| --- | --- |
| `"all"` | 忽略所有警告 |
| `"unchecked"` | 忽略未检查的类型转换警告 |
| `"deprecation"` | 忽略使用过时API的警告 |
| `"rawtypes"` | 忽略使用原始类型的警告（如 `List`而不是 `List<String>`<br/>） |
| `"unused"` | 忽略未使用的变量或方法的警告 |


5. 作用范围：与放的位置有关例如放置在`main`方法前，那么抑制警告的范围就是整个`main`方法内
6. 示例

```java
package com.aurora.Annotaion;

import java.util.ArrayList;
import java.util.List;

@SuppressWarnings({"rawtypes", "unchecked", "unused"})
public class SuppressWarningsDemo {
    public static void main(String[] args) {

        //使用原始类型的警告，可使用"rawtypes"忽略
        List list = new ArrayList();

        //未检查的类型转换警告，可使用"unchecked忽略
        list.add("Jack");
        list.add("Tom");
        list.add("mary");

        //未使用的变量或方法的警告，可使用"unused"忽略
        int i;

        System.out.println(list.get(1));
    }

}
```

+ 使用`SuppressWarning`之前

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762950329555-f04e0878-9122-4954-82ee-6ddc8bcd702b.png)

+ 使用`SupressWarning`之后

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1762950285626-fd4b9fec-3b31-4868-9a4d-97b8474f271a.png)

+ 可以看到`SuppressWarning`放在的整个类外，所以对整个类作用，也可以灵活改变位置，例如单独放在会报警告的语句前

## JDK的元Annotation（元注解）
### 元注解的介绍
1. JDK中的元Annotation用于修饰其它的Annotation
2. 元注解的种类
+ <font style="color:rgb(31, 35, 40);">Retention //指定注解的作用范围，三种SOURCE,CLASS,RUNTIME</font>
+ <font style="color:rgb(31, 35, 40);">Target // 指定注解可以在哪些地方使用</font>
+ <font style="color:rgb(31, 35, 40);">Documented //指定该注解是否会在javadoc 体现</font>
+ <font style="color:rgb(31, 35, 40);">Inherited //子类会继承父类注解</font>

### @Retention
1. <font style="color:rgb(31, 35, 40);">概述：只能用于修饰一个Annotation 定义, 用于指定该Annotation 可以保留多长时间, @Rentention 包含一个RetentionPolicy类型的成员变量, 使用@Rentention 时必须为该value 成员变量指定值</font>
2. **<font style="color:rgb(31, 35, 40);">@Retention 的三种值：</font>**
+ `<font style="color:rgb(31, 35, 40);">RetentionPolicy.SOURCE</font>`<font style="color:rgb(31, 35, 40);">: 编译器使用后，直接丢弃这种策略的注释</font>
+ `<font style="color:rgb(31, 35, 40);">RetentionPolicy.CLASS</font>`<font style="color:rgb(31, 35, 40);">: 编译器将把注解记录在class 文件中. 当运行Java 程序时, JVM 不会保留注解。这是默认值</font>
+ `<font style="color:rgb(31, 35, 40);">RetentionPolicy.RUNTIME</font>`<font style="color:rgb(31, 35, 40);">:编译器将把注解记录在class 文件中. 当运行Java 程序时, JVM 会保留注解. 程序可以通过反射获取该注解。</font>
3. <font style="color:rgb(31, 35, 40);">示例：</font>`<font style="color:rgb(31, 35, 40);">@Override</font>`<font style="color:rgb(31, 35, 40);">的源代码</font>

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE) // 编译器编译时生效，不会写入到class文件中
public @interface Override {
}
```

### @Target
1. 概述：<font style="color:rgb(31, 35, 40);">用于修饰 Annotation定义,用于指定被修饰的Annotation</font>**<font style="color:rgb(31, 35, 40);">能用于修饰哪些程序元素</font>**<font style="color:rgb(31, 35, 40);">。@Target 也包含一个名为value的成员变量。</font>
2. `<font style="color:rgb(31, 35, 40);">@Target</font>`<font style="color:rgb(31, 35, 40);">源码</font>

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
    /**
     * Returns an array of the kinds of elements an annotation type
     * can be applied to.
     * @return an array of the kinds of elements an annotation type
     * can be applied to
     */
    ElementType[] value();	//这里查看ElementType的源码就可以看到所有的取值
}
```

3. `@Target`能修饰的元素类型（`ElemntType`取值）

| 值 | 含义 |
| --- | --- |
| `TYPE` | 类、接口、枚举 |
| `FIELD` | 成员变量 |
| `METHOD` | 方法 |
| `PARAMETER` | 方法参数 |
| `CONSTRUCTOR` | 构造方法 |
| `LOCAL_VARIABLE` | 局部变量 |
| `ANNOTATION_TYPE` | 另一个注解 |
| `PACKAGE` | 包 |
| `TYPE_PARAMETER` | 泛型类型参数（JDK 1.8+） |
| `TYPE_USE` | 类型使用处（JDK 1.8+） |


### @Documented
1. <font style="color:rgb(31, 35, 40);">概念：</font>`<font style="color:rgb(31, 35, 40);">@Documented</font>`<font style="color:rgb(31, 35, 40);">用于指定被该元 Annotation修饰的Annotation类将被javadoc工具提取成文档,即在生成文档时，可以看到该注解。</font>
2. <font style="color:rgb(31, 35, 40);">说明：</font>**<font style="color:rgb(31, 35, 40);">定义为 Documented 的注解必须设置 </font>**`**<font style="color:rgb(31, 35, 40);">Retention </font>**`**<font style="color:rgb(31, 35, 40);">值为 </font>**`**<font style="color:rgb(31, 35, 40);">RUNTIME</font>**`<font style="color:rgb(31, 35, 40);">。</font>

### <font style="color:rgb(31, 35, 40);">@Inherited</font>
1. <font style="color:rgb(31, 35, 40);">概念：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation,则其子类将自动具有该注解。</font>

