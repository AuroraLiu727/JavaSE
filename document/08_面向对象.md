# 类和对象
## 面向对象的介绍
1. 定义：把现实世界中的事物抽象为“对象”，用对象之间的关系和交互来构建程序。也就是很多功能别人已经实现好了，我们只需要直接拿过来用即可
2. 什么时候使用面向对象编程思想：
+ 调用别人的功能时
+ 在一个类中想使用别的类中的成员时

不需要关心使用的功能是怎么实现的，只需要知道怎么使用即可。

3. 使用方式：
+ 先`new`一个对象，然后`对象.属性名()`、`对象.方法名()`的方式调用
+ 特殊：如果调用的成员带`static`关键字（静态成员或静态方法），不需要`new`，直接`对象.属性名()`、`对象.方法名()`即可
4. 示例

```java
Scanner sc = new Scanner(System.in);	//new
int data = sc.nextInt();	//调用

Random random = new Random();	//new
int data = random.nextInt();	//调用
```

```java
package com.aurora.OOP;

import java.util.Arrays;

public class OOPDemo01 {
    /*
        面向对象示例
     */
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4};
        System.out.println(Arrays.toString(arr));
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1755835486096-d1b8869c-b6e6-476a-8954-0799232b71e4.png)

本例中，`Arrays`就是我们找来的对象，`toString`就是此对象中实现好的功能

## 类和对象
### 类(实体类)_class
1. 测试类与实体类
+ 测试类：带`main`方法的类，主要是运行代码的
+ 实体类：是一类事物的抽象表示形式，例如：人类、狗类、猫类
2. 组成部分
+ 属性(成员变量)：这一类事物有什么
    - 定义位置：类中方法外
    - 作用范围：作用于当前类
    - 定义格式：`数据类型 变量名`
    - 默认值:
        * 整数:0
        * 小数:0.0
        * 字符:'\u0000'
        * 布尔:false
        * 引用:null
+ 行为(成员方法)：
    - 这一类事物都能干什么
    - 定义方式：与上一节学的方法相比，只需要去掉`static`关键字即可，即`public 返回值类型 成员方法名{}`
3. 示例

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1755840956236-cc559884-8727-474d-9315-a40ed02332d8.png)

```java
package com.aurora.OOP.class_object;

public class Person {
    //属性->成员变量
    String name;
    int age;

    //行为->成员方法
    public void eat(){
        System.out.println("吃饭");
    }

    public String sleep(){
        return "睡觉";
    }

}

```

### 对象
1. 概述：一类事物的具体体现
2. 使用
+ 导包：`import 包名.类名`
    - 如果两个类在同一个包下,想要使用对方的成员不需要导包
    - 如果两个类不在同一个包下,想要使用对方的成员需要导包
    - 特殊包:java.lang -> 使用lang包下的类不需要导包 -> String
+ 创建对象：想要使用哪个类中的成员，就`new`哪个类的对象
    - `类名 对象名 = new 类名()`
    - 例如：`Person person = new Person();`
+ 调用成员（成员变量，成员方法）：想要使用哪个类中的成员，就用哪个类的对象去点哪个成员
    - `对象名.成员变量 = 值`
    - 对象名.方法名() -> 调用的是无参无返回值方法
    - 对象名.方法名(实参) -> 调用的是有参无返回值方法
    - 数据类型 变量名 = 对象名.方法名() -> 调用的是无参有返回值方法
    - 数据类型 变量名 = 对象名.方法名(实参) -> 调用的是有参有返回值方法
3. 示例

`Person`类的定义见1.2.1

```java
package com.aurora.OOP.class_object;

public class PersonDemo01 {
    public static void main(String[] args) {
        Person person = new Person();
        System.out.println(person.name);
        System.out.println(person.age);
        
        person.name = "liu";
        person.age = 21;
        System.out.println(person.name);
        System.out.println(person.age);

        person.eat();
        String s = person.sleep();
        System.out.println(s);
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1755841423634-713eab5d-c0ba-478c-b789-92b32efaeaf4.png)

### 练习
需求：用代码去描述一个手机类，在测试类中为手机的属性赋值，并且调用手机类中的功能

```java
package com.aurora.OOP.class_object;

public class Phone {
    String brand;
    String color;
    int price;

    public void call(String name){
        System.out.println("给" + name + "打电话");
    }

    public String message(){
        return "发短信";
    }
}

```

```java
package com.aurora.OOP.class_object;

public class PhoneDemo01 {
    /*
        调用手机类
     */
    public static void main(String[] args) {
        Phone phone = new Phone();
        phone.brand = "vivo";
        phone.color = "blue";
        phone.price = 3099;

        System.out.println(phone.brand);
        System.out.println(phone.color);
        System.out.println(phone.price);

        phone.call("liu");
        String s = phone.message();
        System.out.println(s);
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1755842309134-869513b4-f962-424e-b2e6-bcef22cf3263.png)

## 匿名对象的使用
1. 什么是匿名对象：通常我们在定义对象时，定义的语句例如`Random random = new Random();`，所谓的匿名对象，就是在定义时没有等号左边的部分，只有等号右边的部分，使用方式：`new 对象().成员`
2. 适用情况
+ 如果只是想单纯的调用一个方法，让方法执行，可以考虑使用匿名对象
+ 如果涉及到赋值，不能使用匿名对象
3. 使用

```java
package com.aurora.OOP.class_object;

public class PersonDemo02 {
    /*
        匿名对象的使用
     */
    public static void main(String[] args) {
        //使用匿名对象
        new Person().eat();

        //涉及赋值时不能使用
        new Person().name = "liu";
        System.out.println(new Person().name);  //null
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1755927250954-2783f7b9-fc24-45f2-92eb-f4dac250c763.png)

# 成员变量和局部变量的区别
1. 定义位置不同
+ 成员变量：类中方法外
+ 局部变量：定义在方法之中或者参数位置
2. 初始化值不同
+ 成员变量：有默认值，所以不需要手动赋值，就可以直接使用
+ 局部变量：没有默认值，所以需要先动手赋值，再使用
3. 作用范围不同
+ 成员变量：作用于整个类
+ 局部变量：只作用于自己所在的方法，其他方法使用不了
4. 内存位置不同
+ 成员变量：在堆中，跟着对象走
+ 局部变量：在栈中，跟着方法走
5. 生命周期不同
+ 成员变量：随着对象的创建而产生，随着对象的消失而消失
+ 局部变量：随着方法的调用而产生，随着方法的调用完毕而消失

```java
public class Person {
    String name;//成员变量
    public void eat(){
        int i = 10;//局部变量
        System.out.println(i);

        System.out.println(name);//成员变量不用手动赋值可以直接使用,因为有默认值
    }

    public void drink(){
        int j;
        //System.out.println(j);//局部变量没有默认值,所以需要手动赋值再使用
        System.out.println(name);

        //System.out.println(i);//i是eat方法的局部变量,在drink中使用不了
    }
}
```

# 类和对象练习
需求:定义一个类MyDate,属性有 year  month  day

再定义一个类Citizen(公民类),属性有 name(String类型)  birthday(MyDate类型)  idCard(String),为这三个属性赋值,然后将值取出来

```java
package com.aurora.OOP.class_object;

public class MyDate {
    int year;
    int month;
    int day;
}

```

```java
package com.aurora.OOP.class_object;

public class Citizen {
    //姓名
    String name;

    /*
        生日 MyDate类型
        MyDate属于自定义类型(引用数据类型)，在操作之前需要new对象再赋值，
        如果不new对象就直接赋值，会出现空指针异常(NullPointerException)
        空指针异常：当一个对象为null时，再调用此对象中的其他成员
     */
    MyDate birthday = new MyDate();
    
    //身份证
    String idCard;
}

```

```java
package com.aurora.OOP.class_object;

public class CitizenDemo01 {
    public static void main(String[] args) {
        Citizen citizen = new Citizen();
        citizen.name = "liu";
        citizen.idCard = "123";

        citizen.birthday.year = 2000;
        citizen.birthday.month = 1;
        citizen.birthday.day = 1;

        System.out.println(citizen.name);
        System.out.println(citizen.idCard);
        System.out.println(citizen.birthday.year);
        System.out.println(citizen.birthday.month);
        System.out.println(citizen.birthday.day);
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1755930268731-5689afa7-edb7-4bab-843d-abb09acef618.png)

一个问题： 为什么再`Citizen`类中，再定义`birthday`时不是直接`Mydate birthday;`而是`Mydate birthday = new MyDate; ` 

解释：

1. 写成`Mydate birthday;`时，这表示在 `Citizen` 类中声明了一个 **引用变量**`birthday`，但是 **它还没有指向任何对象**。
+ 此时 `birthday` 的值是 `null`
+ 如果你直接用 `citizen.birthday.year = 2000;`，就会报 `**NullPointerException**`**（空指针异常）**，因为 `birthday` 还没真正创建对象。
+ **空指针异常(**`**NullPointerException**`**)：**当一个对象为null时，再调用此对象中的其他成员
2. 写成`Mydate birthday = new MyDate;`时， 这表示：在 `Citizen` 类创建的时候，**同时也创建了一个新的 **`**MyDate**`** 对象**，并让 `birthday` 指向它。  这时再写`citizen.birthday.year = 2000;`就不会报错，因为`birthday`已经不是`null`了。

# static关键字
## static的介绍及基本使用
1. 概述：`static`关键字是一个静态关键字
2. 使用：
+ 修饰一个成员变量：`static 数据类型 变量名`
+ 修饰一个方法:

```java
修饰符 static 返回值类型 方法名(形参){
    方法体;
    return 结果;
}
```

3. 调用静态成员：`类名.静态成员`直接调用，不需要`new`对象
4. 静态成员特点：
+ 静态成员属于类成员（由该类创建出的对象，都默认有这些静态成员），不属于对象成员（非静态的成员属于对象成员）
+ 凡是根据静态成员所在的类创建出来的对象，都可以共享这个静态成员
+ 静态成员会随着类的加载而加载
+ 静态成员优先于非静态成员存在内存中
5. 注意
+ 如果一个类创建了多个对象，其中一个对象修改了类中的静态成员，那其他对象的该静态成员的默认值也会改变，**即所有对象共享同一个静态变量，修改后所有变量都能看到**
+ 如果直接使用`类名.静态变量 = 值`的形式给静态变量赋值，那这个值会共享给所有对象
6. 示例

```java
package com.aurora.OOP.StaticDemo;

public class StudentDemo01 {
    public static void main(String[] args) {
        //给静态成员赋值，不需要new
        Student.classroom = "211";

        Student s1 = new Student();
        s1.name = "张三";
        s1.age = 21;

        Student s2 = new Student();
        s2.name = "李四";
        s2.age = 20;

        //所有对象共享同一个静态变量
        System.out.println(s1.name + "," + s1.age + "岁," + s1.classroom + "班");
        System.out.println(s2.name + "," + s2.age + "岁," + s2.classroom + "班");

        //所有对象共享同一个静态变量，修改后所有变量都能看到
        s1.classroom = "985";
        System.out.println(s1.name + "," + s1.age + "岁," + s1.classroom + "班");
        System.out.println(s2.name + "," + s2.age + "岁," + s2.classroom + "班");
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1756123218130-45364846-b646-4fa4-a067-62abbe2ced53.png)

## static修饰成员的访问特点
1. 在静态方法中能直接访问非静态成员吗？
+ 不能，因为静态成员先产生，它随着类的加载而加载，而非静态成员属于对象，需要创建对象后才产生
+ ![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1756191233337-e207752d-1c90-4f5c-b9c4-e9cf0603314a.png)
+ 可见静态方法(`main`方法)不能直接访问非静态方法`method03`
+ 如果静态成员想访问非静态成员，需要`new`对象，再去访问

```java
package com.aurora.OOP.StaticDemo;

public class Test01 {
    public static void main(String[] args) {
        Test01 test01 = new Test01();
        test01.method03();
    }

    public static void method01(){

    }

    public static void method02(){

    }
    public void method03(){

    }

}

```

+ 不同类中也是一样

```java
package com.aurora.OOP.StaticDemo;

public class Person {
    public void eat(){
        System.out.println("吃饭");
    }
}
```

```java
package com.aurora.OOP.StaticDemo;

public class Test01 {
    public static void main(String[] args) {
        Person person = new Person();
        person.eat();
    }
}

```

2. 在非静态方法中能访问静态成员吗？
+ 能
+ 同类中
    - 直接调用
    - 类名调用
+ 不同类中：类名调用

```java
package com.aurora.OOP.StaticDemo;

public class Test01 {
    public static void main(String[] args) {
    }

    public static void method01(){

    }

    public void method03(){
        //同类中非静态方法访问静态方法
        method01();         //直接调用
        Test01.method01();  //类名调用
        
        //不同类中
        Person.drink();     //类名调用
    }

}

```

```java
package com.aurora.OOP.StaticDemo;

public class Person {
    public void eat(){
        System.out.println("吃饭");
    }

    public static void drink(){
        System.out.println("喝水");
    }
}

```

3. 在静态方法中能访问静态成员吗？
+ 能
+ 同类中
    - 直接调用
    - 类名调用
+ 不同类中：类名调用

```java
package com.aurora.OOP.StaticDemo;

public class Test01 {
    public static void main(String[] args) {
        
    }

    public static void method01(){
        //同一类中的静态成员访问静态成员
        method02();     //直接调用
        Test01.method02();  //类名调用
        
        //不同类中的静态成员访问静态成员
        Person.drink();     //类名调用
    }

    public static void method02(){

    }
    public void method03(){
        
    }

}

```

```java
package com.aurora.OOP.StaticDemo;

public class Person {
    public void eat(){
        System.out.println("吃饭");
    }

    public static void drink(){
        System.out.println("喝水");
    }
}

```

4. 在非静态方法中能访问非静态成员吗？
+ 能
+ 同类中
    - 直接调用
    - `new`对象调用(**因为这是非静态方法，不能直接类名点调用**)
+ 不同类中：`new`对象调用

```java
package com.aurora.OOP.StaticDemo;

public class Test01 {
    public static void main(String[] args) {
        
    }

    public static void method01(){
        
    }

    public static void method02(){

    }
    public void method03(){
        
    }

    public void method04(){
        //同一类中非静态访问非静态
        method03();     //直接调用
        new Test01().method03();    //对象调用(因为这是非静态方法，不能直接类名点调用)

        //不同类中非静态访问非静态
        new Person().eat();     //只能new对象调用
    }

}

```

```java
package com.aurora.OOP.StaticDemo;

public class Person {
    public void eat(){
        System.out.println("吃饭");
    }

    public static void drink(){
        System.out.println("喝水");
    }
}

```

## 静态方法的使用
+ 问题1:既然static成员那么好使(类名直接调用),那么我们在实际开发中,能不能将所有的成员都定义成静态的呢?
    -  不能
    - 原因:由于静态成员会随着类的加载而加载,如果将所有的成员都变成静态的,那么类一加载,静态成员都会进内存,会大量占用内存空间
+ 问题2:那么静态成员都啥时候定义呢?
    - 一般情况下,我们在抽取工具类的时候可以将工具类中的所有成员都定义成静态的
+ 问题3:啥时候定义工具类?
    - 比如我们在写代码的过程中,发现有的功能在反复实现,代码一样,功能一样,此时就可以抽取出来,形成工具类

```java
package com.aurora.OOP.StaticDemo;

public class ArraysUtils {
    private ArraysUtils() {
    }
    
    public static int getMax(int[] arr){
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max){
                max = arr[i];
            }
        }
        return max;
    }
}

```

```java
package com.aurora.OOP.StaticDemo;

public class ArrayDemo01 {
    public static void main(String[] args) {
        int[] arr = {5, 3, 4, 6, 7, 8, 3};
        int max = ArraysUtils.getMax(arr);
        System.out.println(max);
    }
}

```

**一个小细节：**

+ `ArraysUtils`中的构造方法使用`private`修饰的，而不是用`public`修饰，这是因为工具类中的成员都是静态的，静态成员直接类名调用就好了，不需要去`new`对象，而构造方法被`private`修饰后，在别的类中，就不能利用构造方法`new`对象了。所以一般工具类中的构造方法都是用`private`修饰的。

# 可变参数
## 介绍和基本使用
1. 只明确参数的类型，但是不明确参数个数，此时就可以定义成可变参数
2. 定义格式：`数据类型...变量名`
3. 注意：
+ 可变参数的本质是一个数组
+ 参数位置不能连续写多个可变参数，而且当可变参数和其他普通参数一起使用时，可变参数需要放到参数列表的最后
4. 示例

```java
package com.aurora.OOP.StaticDemo;

public class variable_args {
    public static void main(String[] args) {
        sum(1, 2, 3, 4, 5);
        sum1(1, 1, 1, 2, 3, 4, 5);
    }

    //可变参数
    public static void sum(int... arr){
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        System.out.println(sum);
    }

    //可变参数与普通参数结合使用
    public static void sum1(int a, int b, int... arr){
        int sum = 0;
        sum += a;
        sum += b;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        System.out.println(sum);
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1757332735673-0e5f9cf5-acdc-4eea-83d9-a2160bbf7775.png)

## 字符串拼接
1. 需求：返回n个字符串拼接结果，如果没有传入字符串，那么返回空字符串`""`

```java
package com.aurora.OOP.variable_args;

public class strConcatDemo01 {
    public static void main(String[] args) {
        //没有传入字符串
        String str1 = concat();
        System.out.println(str1);   //空字符串

        String str2 = concat("hello", ",", "world", ",", "Java");
        System.out.println(str2);
    }

    public static String concat(String... str){
        if (str.length == 0){
            return "";
        }
        String concat_str = "";
        for (int i = 0; i < str.length; i++) {
            concat_str += str[i];
        }
        return concat_str;
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1757333387637-27b72e5a-196d-4b36-876a-40d679ec2ff1.png)

2. n个字符串进行拼接，每一个字符串之间使用某字符进行分割，如果没有传入字符串，那么返回空字符串`""`

```java
package com.aurora.OOP.variable_args;

public class strConcatDemo02 {
    /*
        n个字符串进行拼接，每一个字符串之间使用某字符进行分割，如果没有传入字符串，那么返回空字符串""
     */
    public static void main(String[] args) {
        String concat_str = concat("-", "Java", "Python", "Matlab");
        System.out.println(concat_str);
    }

    public static String concat(String splitSign, String... str){
        if (str.length == 0){
            return "";
        }
        String concat_str = "";
        for (int i = 0; i < str.length - 1; i++) {
            concat_str += str[i];
            concat_str += splitSign;
        }
        concat_str += str[str.length - 1];
        return concat_str;
    }

}

```

# 递归
## 介绍和基本使用
1. 概述：方法内部自己调用自己
2. 分类
+ 直接递归

```java
public static void method(){
    method();
}
```

+ 间接递归

```java
A(){
    B();
}

B(){
    C();
}

C(){
    A();
}
```

3. 注意
+ 递归必须要有出口，否则会出现"栈内存溢出"
+ 递归即使有出口，递归次数也不要太多，因为递归很占用内存

## 利用递归输出3到1
```java
package com.aurora.OOP.recursion;

public class recursionDemo01 {
    /*
        利用递归输出3到1
     */
    public static void main(String[] args) {
        method(3);
    }

    public static void method(int num){
        System.out.println(num);
        if (num > 1){
            method(num - 1);
        }
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1757337083432-d92713f0-7fea-4f4b-b157-e66331a20cdc.png)

## 求n!（n的阶乘）
```java
package com.aurora.OOP.recursion;

public class recursionDemo02 {
    /*
        求n的阶乘
     */
    public static void main(String[] args) {
        int result = jiecheng(5);
        System.out.println(result);
    }

    public static int jiecheng(int n){
        if(n == 1){
            return 1;
        }else{
            return n * jiecheng(n - 1);
        }
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1757337458970-07836b12-74fc-4e2c-8d83-d7da03985bc7.png)

## 斐波那契数列
1. 需求：计算斐波那契数列的第`n`个值
2. 实现

```java
package com.aurora.OOP.recursion;

public class recursionDemo03 {
    /*
        输出斐波那契数列的前n个值
     */
    public static void main(String[] args) {
        int result = Fibonacci(10);
        System.out.println(result);

        //输出Fibonacci数列的前10个值
        for(int i = 1; i <= 10; i++){
            System.out.print(Fibonacci(i) + " ");
        }
    }


    public static int Fibonacci(int n){
        if (n == 1 || n == 2){
            return 1;
        }else{
            return Fibonacci(n - 1) + Fibonacci(n - 2);
        }
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1757338337182-580f44cf-f3bf-4dfb-8400-33fa7da6ac84.png)

# 数组常见算法
## 数组翻转
### 步骤
1. 如何先确定数组两端的位置
+ `int min = 0;`
+ `int max = arr.length - 1;`
2. 两个元素怎样交换位置
+ `int temp = arr[min];`
+ `arr[min] = arr[max];`
+ `arr[max] = temp;`
3. 交换之后，`min`和`max`怎样变化
+ `min++`, `max--`
4. 终止条件
+ `min >= max`

### 示例
```java
package com.aurora.OOP.ArrayArithmetic;

public class ArrayReverse {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8};
        for (int min = 0, max = arr.length - 1; min <= max; min++, max--){
            int temp = arr[min];
            arr[min] = arr[max];
            arr[max] = temp;
        }

        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1758079317796-3dfac359-7826-4bda-8ef6-555a3da5475a.png)

## 冒泡排序
### 冒泡排序原理
1. 基本思想
+ 从头到尾一次比较相邻的两个元素，如果他们的顺序（大小）不符合要求，就交换他们
+ 每一轮比较滞后，都会把最大或最小的元素（根据升序/降序的不同）逐步移动到数组的一端
+ 重复这个过程，直到所有元素都有序
2. 步骤举例

假设数组：`[5, 3, 8, 4, 2]`

+ **第一轮**：
    - 比较 `5` 和 `3`，交换 → `[3, 5, 8, 4, 2]`
    - 比较 `5` 和 `8`，不交换 → `[3, 5, 8, 4, 2]`
    - 比较 `8` 和 `4`，交换 → `[3, 5, 4, 8, 2]`
    - 比较 `8` 和 `2`，交换 → `[3, 5, 4, 2, 8]`  
→ 最大的 `8` 已经排到末尾。
+ **第二轮**：
    - 比较 `3` 和 `5`，不交换 → `[3, 5, 4, 2, 8]`
    - 比较 `5` 和 `4`，交换 → `[3, 4, 5, 2, 8]`
    - 比较 `5` 和 `2`，交换 → `[3, 4, 2, 5, 8]`  
→ 第二大 `5` 已经排到倒数第二个位置。
+ **第三轮**：
    - 比较 `3` 和 `4`，不交换
    - 比较 `4` 和 `2`，交换 → `[3, 2, 4, 5, 8]`
+ **第四轮**：
    - 比较 `3` 和 `2`，交换 → `[2, 3, 4, 5, 8]`

### 代码实现
1. 基础版本

```java
package com.aurora.OOP.ArrayArithmetic;

public class BubbleSortDemo01 {
    /*
        基础版本的冒泡排序
     */
    public static void main(String[] args) {
        int[] arr = {5, 4, 3, 2, 1};
        BubbleSort(arr);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }

    public static void BubbleSort(int[] arr){
        int temp;
        //外层循环控制趟数
        for (int i = 0; i < arr.length - 1; i++){
            //内层循环控制比较次数
            for (int j = 0; j < arr.length - 1 - i; j++){
                //升序排序，如果需要降序排序则修改成<
                if(arr[j] > arr[j + 1]){
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1758112477755-6e45d0f3-5c2f-4af7-8604-0c48068bdc86.png)

2. 优化版本（加标志位，减少无效比较）

```java
package com.aurora.OOP.ArrayArithmetic;

public class BubbleSortDemo02 {
    /*
        在冒泡排序时加入标志位，减少无效排序
     */
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        bubbleSort(arr);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }

    public static void bubbleSort(int[] arr){
        boolean flag;
        int count = 0;  //记录比较的趟数
        for(int i = 0; i < arr.length - 1; i++){
            flag = false;
            for(int j = 0; j < arr.length - 1 - i; j++){
                if(arr[j] > arr[j + 1]){
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    flag = true;    //表示这一趟进行了交换
                }
            }
            count++;
            if(!flag){
                break;  //flag为假，表示本趟没有交换，数组已经有序，没有必要继续排序
            }
        }
        System.out.println("共比较的趟数为：" + count);
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1758113066588-a63b2806-25f9-4a35-8b70-6b94dc9ad732.png)

可以发现在数组本来就有序时只需要比较一趟就可由标志位知道数组已经有序，避免不必要的比较。

# 对象数组
## 对象数组的使用
1. 需求：定义一个长度为3的数组，存储3个Person对象，遍历数组，将三个Person对象中的属性值获取出来
2. 示例

```java
package com.aurora.OOP.ObjectArray;

public class Person {
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

```

```java
package com.aurora.OOP.ObjectArray;

public class ObjectArrayDemo01 {
    public static void main(String[] args) {
        Person[] person = new Person[3];
        person[0] = new Person("张三", 18);
        person[1] = new Person("李四", 20);
        person[2] = new Person("王五", 30);

        for (int i = 0; i < person.length; i++) {
            System.out.println(person[i].getName() + " " + person[i].getAge());
        }
    }
}

```

## 练习
1. 定义学生类`Student`，生命姓名和成绩成员变量
2. 测试类`ObjectArrayTest`的`main`中创建一个可以装三个学生对象的数组，并且按照学生成绩排序，显示学生信息

```java
package com.aurora.OOP.ObjectArray;

public class Student {
    private String name;
    private int grade;

    public Student() {
    }

    public Student(String name, int grade) {
        this.name = name;
        this.grade = grade;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getGrade() {
        return grade;
    }

    public void setGrade(int grade) {
        this.grade = grade;
    }
}

```

```java
package com.aurora.OOP.ObjectArray;

public class ObjectArrayTest {
    /*
        1. 定义学生类Student，生命姓名和成绩成员变量
        2. 测试类ObjectArrayTest的main中创建一个可以装三个学生对象的数组，并且按照学生成绩排序，显示学生信息
     */
    public static void main(String[] args) {
        Student[] students = new Student[3];
        students[0] = new Student("张三", 90);
        students[1] = new Student("李四", 80);
        students[2] = new Student("王五", 100);

        for (int i = 0; i < students.length; i++){
            for (int j = 0; j < students.length - 1 - i; j++){
                if (students[j].getGrade() > students[j + 1].getGrade()) {
                    Student temp = students[j];
                    students[j] = students[j + 1];
                    students[j + 1] = temp;
                }
            }
        }

        for (int i = 0; i < students.length; i++) {
            System.out.println(students[i].getName() + "\t" + students[i].getGrade());
        }
    }
}

```

