# 概述
1. 定义：父类怎么形成的:我们的定义了多个类,发现这些类中有很多重复性的代码,我们就定义了一个父类,将相同的代码抽取出来放到父类中,其他的类直接继承这个父类,就可以直接使用父类中的内容了
2. 注意
+ 子类可以继承父类中的私有和非私有成员，但是不能使用父类中的私有成员
+ 构造方法不能继承
3. 继承怎么学：不要从是否“拥有”方面来学习，要从是否能“使用”方面来学习

# 继承如何使用
1. 使用步骤
+ 定义一个父类，在其中定义重复性的代码
+ 定义一个子类继承父类，`字类 extends 父类`
+ 创建子类对象，直接使用父类中的非私有成员
2. 使用示例
+ **(Employee)父类**

```java
package com.aurora.extendsUse;

public class Employee {
    String name;
    int age;

    public void work(){
        System.out.println("工作");
    }

    private void eat(){
        System.out.println("吃饭");
    }
}
```

+ **(Teacher)子类**

```java
package com.aurora.extendsUse;

public class Teacher extends Employee{
}

```

+ **(Manager)子类**

```java
package com.aurora.extendsUse;

public class Manager extends Employee{
}

```

+ **(Test01)测试类**

```java
package com.aurora.extendsUse;

public class Test01 {
    public static void main(String[] args) {
        Teacher teacher = new Teacher();
        teacher.name = "张三";
        teacher.age = 23;
        System.out.println(teacher.name + "\t" + teacher.age);
        teacher.work();
        //teacher.eat();    //报错，子类继承父类后不能使用父类的私有成员，只能使用父类的非私有成员

        Manager manager = new Manager();
        manager.name = "李四";
        manager.age = 23;
        System.out.println(manager.name + "\t" + manager.age);
        manager.work();
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1760445001393-66c4a83f-720a-45c9-8635-85fd5537c4da.png)

# 继承中，成员变量和成员方法的访问特点
## 成员变量
### 子类和父类中的成员变量不重名时
1. 调用规则：
+ 子类对象既可以调用子类的变量，也可以调用从父类继承过来的成员变量
+ 父类对象只能调用父类中的成员变量
2. 使用示例
+ **父类**

```java
package com.aurora.extendsUse.MemberVariable;

public class Fu {
    int numFu = 100;
}

```

+ **子类**

```java
package com.aurora.extendsUse.MemberVariable;

public class Zi extends Fu {
    int numZi = 99;
}

```

+ **测试类**

```java
package com.aurora.extendsUse.MemberVariable;

public class Test02 {
    public static void main(String[] args) {
        //创建父类对象
        Fu fu = new Fu();
        System.out.println(fu.numFu);
        //System.out.println(fu.numZi);     //父类不能直接调用子类中特有的成员

        //创建子类对象
        Zi zi = new Zi();
        System.out.println(zi.numZi);
        System.out.println(zi.numFu);   //子类可以直接调用所父类中的非私有成员

    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1760446697530-d7aa5394-3637-4491-b9ad-6d22a40c5172.png)

### 子类和父类中的成员变量重名
1. 调用规则
+ 子类和父类中有同名成员变量时，谁调用（`父类.同名变量`/`子类.同名变量`）就是谁的成员
2. 使用示例
+ **父类**

```java
package com.aurora.extendsUse.MemberVariable;

public class Fu {
    int numFu = 100;
    int num = 1;
}

```

+ **子类**

```java
package com.aurora.extendsUse.MemberVariable;

public class Zi extends Fu {
    int numZi = 99;
    int num = 2;
}

```

+ **测试类**

```java
package com.aurora.extendsUse.MemberVariable;

public class Test03 {
    public static void main(String[] args) {
        //父类
        Fu fu = new Fu();
        System.out.println(fu.num);

        //子类
        Zi zi = new Zi();
        System.out.println(zi.num);
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1760447356303-44282387-c5b5-4604-9e3d-e69c687e7a26.png)

## 成员方法
1. 也是谁调用就是谁的方法
2. 示例

```java
package com.aurora.extendsUse.MemberMethod;

public class Fu {
    public void methodFu(){
        System.out.println("我是父类中的methodFu方法");
    }

    public void method(){
        System.out.println("我是父类中的method方法");
    }
}

```

```java
package com.aurora.extendsUse.MemberMethod;

public class Zi extends Fu{
    public void methodZi(){
        System.out.println("我是子类中的methodZi方法");
    }

    public void method(){
        System.out.println("我是子类中的method方法");
    }

}

```

```java
package com.aurora.extendsUse.MemberMethod;

public class Test01 {
    public static void main(String[] args) {
        //父类
        Fu fu = new Fu();
        fu.methodFu();
        fu.method();

        System.out.println("---------------------");
        //子类
        Zi zi = new Zi();
        zi.methodZi();
        zi.method();
        zi.methodFu();

    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1760512083275-81177712-c6f1-46bc-8262-ec024cad1ded.png)

## 当new的对象类型和声明的对象类型不一致时
1. 当new的对象类型和声明的对象类型不一致时，例如`Fu fu = new Zi();`时，调用同名成员变量和同名成员方法的结果是不一样的，区分如下：
+ 调用同名成员变量时，等号左边是谁，就优先调用谁的成员，本例中先调用父类中的成员变量
+ 调用同名成员方法时，看等号右边`new`的是谁，就优先调用谁中的方法，本例中先调用子类中的成员方法
2. 示例

```java
package com.aurora.extendsUse.MemberMethod;

public class Fu {
    String name = "fu";

    public void method(){
        System.out.println("我是父类中的method方法");
    }
}

```

```java
package com.aurora.extendsUse.MemberMethod;

public class Zi extends Fu{
    String name = "zi";

    public void method(){
        System.out.println("我是子类中的method方法");
    }

}

```

```java
package com.aurora.extendsUse.MemberMethod;

public class Test02 {
    public static void main(String[] args) {
        Fu fu1 = new Zi();
        System.out.println(fu1.name);
        fu1.method();
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1760512875046-ba6492c7-ae90-425d-b0e4-828880022014.png)

**调用的是父类中的成员变量（等号左边），子类中的成员方法（等号右边）**

3. **注意**：只能是`Fu fu = new Zi();`，而不能是`Zi zi = new Fu();`

**向上转型：**`**Fu fu = new Zi();**`

**理解方式：**

+ `new Zi()` 创建了一个 **子类对象**。
+ 但它被 **声明为父类类型**（`Fu`）。
+ 因为每个 `Zi` 对象都“包含”一个 `Fu` 部分，所以这样做是安全的。
+ 你可以通过 `fu1` 访问父类中的方法

 即便 `fu1` 编译时看起来是 `Fu` 类型，但运行时仍然是 `Zi` 对象。  



**向下转型：**`**Zi zi = new Fu();**`

**原因：**

+ `new Fu()` 创建的是一个 纯父类对象，它没有子类中的扩展部分。
+ Java 不允许直接把一个“父类对象”强行当成“子类对象”来用。
+ 因为子类可能有父类中没有的字段或方法，如果允许这样做，程序运行时就会出错。

# 方法的重写
1. 概述：子类中有一个和父类方法名以及参数列表相同的方法
2. 前提：继承
3. 访问：看`new`的是谁，先调用谁中的；如果`new`的是子类，就调用子类中重写的方法，子类没有，找父类
4. 检测是否为重写方法：在该方法上方写`@Override`

**示例：**

```java
package com.aurora.extendsUse.overrideDemo;

public class Fu {

    public void method(){
        System.out.println("我是父类中的method方法");
    }
}

```

```java
package com.aurora.extendsUse.overrideDemo;

public class Zi extends Fu{

    @Override
    public void method(){
        System.out.println("我是子类中的method方法");
    }
}

```

```java
package com.aurora.extendsUse.overrideDemo;

public class Test01 {
    public static void main(String[] args) {
        //父类
        Fu fu = new Fu();
        fu.method();

        //子类
        Zi zi = new Zi();
        zi.method();
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1760515210439-3fa5d8e3-766f-45bb-a879-a5dc243cf14a.png)

## 注意事项
1. 子类重写父类方法之后，权限必须保证大于等于父类权限（访问权限），`public > protected > 默认 > private`
2. 子类方法重写父类方法，方法名和参数列表要一样
3. 私有方法、构造方法、静态方法都不能被重写
4. 子类重写父类方法之后，返回值类型应该是父类方法返回值类型的子类类型

## 使用场景
功能升级改造，子类需要对父类中已经实现好的功能进行重新改造

# super和this
## 继承中构造方法的特点
1. 什么是`super`：`super()`代表的是父类无参构造
2. 注意：
+ `new`子类对象时，会先初始化父类（先走父类无参构造方法）
+ 子类中每个构造方法的第一行，默认都会有一个`super()`，即使不写`jvm`也会自动提供一个
3. 示例

```java
package com.aurora.extendsUse.super_and_this;

public class Fu {
    public Fu(){
        System.out.println("我是父类中的无参构造方法");
    }
}

```

```java
package com.aurora.extendsUse.super_and_this;

public class Zi extends Fu{
    public Zi(){
        //super();
        System.out.println("我是子类中的无参构造");
    }

    public Zi(int i){
        //super();
        System.out.println("我是子类中的有参构造");
    }
}

```

```java
package com.aurora.extendsUse.super_and_this;

public class Test {
    public static void main(String[] args) {
        Zi zi = new Zi();
        System.out.println("----------------------");
        Zi zi1 = new Zi(100);
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1760598017518-ff7163db-a068-47bc-a46b-e8ce418d164c.png)

`Zi.java`中的两个构造方法中的`super()`写于不写输出的结果都是一样的，因为jvm会自动加上`super();`

## super与this的具体使用
### super的使用
1. 概述：代表的时父类引用
2. 作用：可以调用父类中的成员
3. **使用：**
+ 调用父类构造方法->在子类中的构造方法中写
    - `super()`->调用父类无参构造
    - `super(实参)`：调用父类有参构造
+ 调用父类成员变量：`super.成员变量名`
+ 调用父类成员方法：`super.成员方法名(实参)`
4. 使用示例

```java
package com.aurora.extendsUse.super_and_this.Demo02;

public class Fu {

    int num = 10;

    public Fu(){
        System.out.println("我是父类中的无参构造方法");
    }

    public Fu(int data){
        System.out.println("我是父类中的有参构造方法，data = " + data);
    }

    public void method(){
        System.out.println("我是父类中的method方法");
    }
}

```

```java
package com.aurora.extendsUse.super_and_this.Demo02;

public class Zi extends Fu{
    int num = 100;

    public Zi(){
        super();    //调用父类中的无参构造
        System.out.println("我是子类中的无参构造");
    }

    public Zi(int data){
        super(10);  //调用父类中的有参构造
        System.out.println("我是子类中的有参构造");
    }

    public void method(){
        super.method(); //调用父类中的method方法
        System.out.println("我是子类中的method方法");
        System.out.println("子类中的num = " + num);    //子类自己的num
        System.out.println("父类中的num = " + super.num);  //父类的num
    }
}

```

```java
package com.aurora.extendsUse.super_and_this.Demo02;

public class Test {
    public static void main(String[] args) {
        //测试调用父类的无参构造
        Zi zi = new Zi();
        System.out.println("----------------");

        //测试调用父类的有参构造
        Zi zi1 = new Zi(99);
        System.out.println("-----------------");

        //测试调用父类的成员方法
        Zi zi2 = new Zi();
        zi2.method();

    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1760601457613-da787fcd-fa19-4bd9-8975-75ea6a344c28.png)

### this的具体使用
1. 概述：`this`代表的是当前对象（哪个对象调用的`this`所在的方法，`this`就代表哪个对象）
2. **作用：**
+ 区分重名的成员变量和局部变量
+ 调用当前对象中的成员
3. **使用**
+ 调用当前对象的构造：在构造中写
    - `this()`：调用当前对象的无参构造
    - `this(实参)`：调用当前对象的有参构造
+ 调用当前对象的成员变量：`this.成员变量名`
+ 调用当前对象的成员方法：`this.成员方法名(实参)`
4. 注意：
+ 不管是`super`还是`this`,只要在构造中使用，都必须在第一行，所以二者不能同时写出来
+ `this` 只能在**实例方法或构造方法**中使用：
    - ✅ 实例方法
    - ✅ 构造函数
    - ❌ 静态方法（如 `main`）中不能用 `this`，因为静态方法**没有对象实例**。

#### this用来区分局部变量和成员变量
当方法参数或局部变量与成员变量同名时，用`this`明确指定**成员变量**

```java
public Person() {
        System.out.println("我是Person中的无参构造");
    }

    public Person(int num) {
        this();
        System.out.println("我是Person中的有参构造, data = " + num);
    }
```

```java
package com.aurora.extendsUse.super_and_this.thisDemo;

public class Test {
    public static void main(String[] args) {
        Person person = new Person();
        person.method();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1760698071655-f1e8dbfd-e2c7-472b-b23b-44acaa562a0d.png)

#### 在构造方法（方法）中调用另一个构造方法（方法）
```java
package com.aurora.extendsUse.super_and_this.thisDemo;

public class Person {
    int num = 10;

    public Person() {
        this(10);   //调用另一个构造方法
        System.out.println("我是Person中的无参构造");
    }

    public Person(int num) {
        this.num = num;
        System.out.println("我是Person中的有参构造");
    }

    public void method() {
        this.method01();    //调用另一个方法
        System.out.println("我是Person中的method方法");
    }

    public void method01(){
        System.out.println("我是Person中的method01方法");
    }
}
```

```java
package com.aurora.extendsUse.super_and_this.thisDemo;

public class Test {
    public static void main(String[] args) {
        Person person = new Person();
        person.method();
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1760698885704-4dd097c1-a518-426f-9605-815d58dad64f.png)

#### 返回当前对象（实现链式调用）
```java
package com.aurora.extendsUse.super_and_this.thisDemo;

public class Student {
    /*
        使用this关键字实现链式调用
     */

    private String name;
    private int age;


    public Student setName(String name) {   //注意：返回值类型为当前对象的类型Student
        this.name = name;
        return this;    //返回当前对象
    }

    public Student setAge(int age) {    
        this.age = age;
        return this;    
    }

    public void show() {
        System.out.println(name + "-" + age);
    }

    public static void main(String[] args) {
        Student student = new Student();
        student
                .setName("张三")
                .setAge(18)
                .show();
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1760699336941-8d3c217b-9952-4981-81c7-f47658d13ee2.png)

#### 作为参数传递当前对象
```java
class Printer {
    public void print(Person p) {
        System.out.println("打印: " + p.name);
    }
}

class Person {
    String name = "Tom";

    public void callPrinter() {
        Printer printer = new Printer();
        printer.print(this); // 把当前对象传进去
    }
}

```

## 继承的特点
1. 继承只支持单继承，不支持多继承，例如`public class A extends B,C{}`时错误的
2. 继承支持多层继承：`public class A extends B{}`,`public B extends C{}`
3. 一个父类可以有多个子类
+ `public A extends C{}`
+ `public B extends C{}`
4. 哪些方法可以继承、重写
+ 构造方法不能继承，也不能被重写
+ 私有方法、静态方法可以继承，但是不能被重写
+ 实例方法（`public void method(){}`这种）可以继承，也可以被重写

## 问题：如何为父类中的private的成员变量赋值
### 利用set赋值
**父类（Employee）**

```java
package com.aurora.extendsUse.super_and_this.Demo04;

public class Employee {
    String name;
    int age;

    public Employee() {
    }

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

```

**子类（Teacher）**

```java
package com.aurora.extendsUse.super_and_this.Demo04;

public class Teacher extends Employee{

}

```

**测试类**

```java
package com.aurora.extendsUse.super_and_this.Demo04;

public class Test {
    public static void main(String[] args) {
        Teacher teacher = new Teacher();

        //使用set方法赋值
        teacher.setName("张三");
        teacher.setAge(18);
        System.out.println(teacher.getName() + "--"  + teacher.getAge());
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1760701810609-a18ee7b9-8a0d-42a9-8ed8-3f22aa87d6ec.png)

### 利用构造方法赋值
**子类（Manager）**

```java
package com.aurora.extendsUse.super_and_this.Demo04;

public class Manager extends Employee{
    public Manager() {
    }

    public Manager(String name, int age) {
        super(name, age);
    }

    //Manager中不需要单独写Getter/Setter方法，因为可以直接从父类Employee中继承过来

}

```

**测试类**

```java
package com.aurora.extendsUse.super_and_this.Demo04;

public class Test02 {
    public static void main(String[] args) {
        Manager manager = new Manager("李四", 20);
        System.out.println(manager.getName() + "--" + manager.getAge());
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1760702090798-8b9315c4-5726-450c-adde-34a7a52ffbbf.png) 

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1760702076327-f7c0b2fd-c5a9-4341-a0d4-56bc6737a0fb.png)

